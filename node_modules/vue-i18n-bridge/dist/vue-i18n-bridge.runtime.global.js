/*!
  * vue-i18n-bridge v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
var VueI18nBridge = (function (exports, vueDemi) {
  'use strict';

  /**
   * Original Utilities
   * written by kazuya kawaguchi
   */
  const inBrowser = typeof window !== 'undefined';
  let mark;
  {
      const perf = inBrowser && window.performance;
      if (perf &&
          perf.mark &&
          perf.measure &&
          perf.clearMarks &&
          // @ts-ignore browser compat
          perf.clearMeasures) {
          mark = (tag) => {
              perf.mark(tag);
          };
      }
  }
  const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
  /* eslint-disable */
  function format(message, ...args) {
      if (args.length === 1 && isObject(args[0])) {
          args = args[0];
      }
      if (!args || !args.hasOwnProperty) {
          args = {};
      }
      return message.replace(RE_ARGS, (match, identifier) => {
          return args.hasOwnProperty(identifier) ? args[identifier] : '';
      });
  }
  const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
  const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
  const friendlyJSONstringify = (json) => JSON.stringify(json)
      .replace(/\u2028/g, '\\u2028')
      .replace(/\u2029/g, '\\u2029')
      .replace(/\u0027/g, '\\u0027');
  const isNumber = (val) => typeof val === 'number' && isFinite(val);
  const isDate = (val) => toTypeString(val) === '[object Date]';
  const isRegExp = (val) => toTypeString(val) === '[object RegExp]';
  const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
  const assign = Object.assign;
  let _globalThis;
  const getGlobalThis = () => {
      // prettier-ignore
      return (_globalThis ||
          (_globalThis =
              typeof globalThis !== 'undefined'
                  ? globalThis
                  : typeof self !== 'undefined'
                      ? self
                      : typeof window !== 'undefined'
                          ? window
                          : typeof global !== 'undefined'
                              ? global
                              : {}));
  };
  function escapeHtml(rawText) {
      return rawText
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&apos;');
  }
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
  }
  /* eslint-enable */
  /**
   * Useful Utilities By Evan you
   * Modified by kazuya kawaguchi
   * MIT License
   * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts
   * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/codeframe.ts
   */
  const isArray = Array.isArray;
  const isFunction = (val) => typeof val === 'function';
  const isString = (val) => typeof val === 'string';
  const isBoolean = (val) => typeof val === 'boolean';
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const isObject = (val) => val !== null && typeof val === 'object';
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const isPromise = (val) => {
      return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const isPlainObject = (val) => {
      if (!isObject(val))
          return false;
      const proto = Object.getPrototypeOf(val);
      return proto === null || proto.constructor === Object;
  };
  // for converting list and named values to displayed strings.
  const toDisplayString = (val) => {
      return val == null
          ? ''
          : isArray(val) || (isPlainObject(val) && val.toString === objectToString)
              ? JSON.stringify(val, null, 2)
              : String(val);
  };
  function join(items, separator = '') {
      return items.reduce((str, item, index) => (index === 0 ? str + item : str + separator + item), '');
  }
  function incrementer(code) {
      let current = code;
      return () => ++current;
  }

  function warn(msg, err) {
      if (typeof console !== 'undefined') {
          console.warn(`[intlify] ` + msg);
          /* istanbul ignore if */
          if (err) {
              console.warn(err.stack);
          }
      }
  }
  const hasWarned = {};
  function warnOnce(msg) {
      if (!hasWarned[msg]) {
          hasWarned[msg] = true;
          warn(msg);
      }
  }

  const isNotObjectOrIsArray = (val) => !isObject(val) || isArray(val);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  function deepCopy(src, des) {
      // src and des should both be objects, and none of them can be a array
      if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
          throw new Error('Invalid value');
      }
      const stack = [{ src, des }];
      while (stack.length) {
          const { src, des } = stack.pop();
          Object.keys(src).forEach(key => {
              if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
                  // replace with src[key] when:
                  // src[key] or des[key] is not an object, or
                  // src[key] or des[key] is an array
                  des[key] = src[key];
              }
              else {
                  // src[key] and des[key] are both objects, merge them
                  stack.push({ src: src[key], des: des[key] });
              }
          });
      }
  }

  const CompileWarnCodes = {
      USE_MODULO_SYNTAX: 1,
      __EXTEND_POINT__: 2
  };

  const CompileErrorCodes = {
      // tokenizer error codes
      EXPECTED_TOKEN: 1,
      INVALID_TOKEN_IN_PLACEHOLDER: 2,
      UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
      UNKNOWN_ESCAPE_SEQUENCE: 4,
      INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
      UNBALANCED_CLOSING_BRACE: 6,
      UNTERMINATED_CLOSING_BRACE: 7,
      EMPTY_PLACEHOLDER: 8,
      NOT_ALLOW_NEST_PLACEHOLDER: 9,
      INVALID_LINKED_FORMAT: 10,
      // parser error codes
      MUST_HAVE_MESSAGES_IN_PLURAL: 11,
      UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
      UNEXPECTED_EMPTY_LINKED_KEY: 13,
      UNEXPECTED_LEXICAL_ANALYSIS: 14,
      // generator error codes
      UNHANDLED_CODEGEN_NODE_TYPE: 15,
      // minifier error codes
      UNHANDLED_MINIFIER_NODE_TYPE: 16,
      // Special value for higher-order compilers to pick up the last code
      // to avoid collision of error codes. This should always be kept as the last
      // item.
      __EXTEND_POINT__: 17
  };
  /** @internal */
  const errorMessages$2 = {
      // tokenizer error messages
      [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
      [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
      [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
      [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
      [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
      [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
      [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
      [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
      [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
      [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
      // parser error messages
      [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
      [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
      [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
      [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
      // generator error messages
      [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
      // minimizer error messages
      [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
  };
  function createCompileError(code, loc, options = {}) {
      const { domain, messages, args } = options;
      const msg = format((messages || errorMessages$2)[code] || '', ...(args || []))
          ;
      const error = new SyntaxError(String(msg));
      error.code = code;
      if (loc) {
          error.location = loc;
      }
      error.domain = domain;
      return error;
  }

  const pathStateMachine =  [];
  pathStateMachine[0 /* States.BEFORE_PATH */] = {
      ["w" /* PathCharTypes.WORKSPACE */]: [0 /* States.BEFORE_PATH */],
      ["i" /* PathCharTypes.IDENT */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],
      ["[" /* PathCharTypes.LEFT_BRACKET */]: [4 /* States.IN_SUB_PATH */],
      ["o" /* PathCharTypes.END_OF_FAIL */]: [7 /* States.AFTER_PATH */]
  };
  pathStateMachine[1 /* States.IN_PATH */] = {
      ["w" /* PathCharTypes.WORKSPACE */]: [1 /* States.IN_PATH */],
      ["." /* PathCharTypes.DOT */]: [2 /* States.BEFORE_IDENT */],
      ["[" /* PathCharTypes.LEFT_BRACKET */]: [4 /* States.IN_SUB_PATH */],
      ["o" /* PathCharTypes.END_OF_FAIL */]: [7 /* States.AFTER_PATH */]
  };
  pathStateMachine[2 /* States.BEFORE_IDENT */] = {
      ["w" /* PathCharTypes.WORKSPACE */]: [2 /* States.BEFORE_IDENT */],
      ["i" /* PathCharTypes.IDENT */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],
      ["0" /* PathCharTypes.ZERO */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */]
  };
  pathStateMachine[3 /* States.IN_IDENT */] = {
      ["i" /* PathCharTypes.IDENT */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],
      ["0" /* PathCharTypes.ZERO */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],
      ["w" /* PathCharTypes.WORKSPACE */]: [1 /* States.IN_PATH */, 1 /* Actions.PUSH */],
      ["." /* PathCharTypes.DOT */]: [2 /* States.BEFORE_IDENT */, 1 /* Actions.PUSH */],
      ["[" /* PathCharTypes.LEFT_BRACKET */]: [4 /* States.IN_SUB_PATH */, 1 /* Actions.PUSH */],
      ["o" /* PathCharTypes.END_OF_FAIL */]: [7 /* States.AFTER_PATH */, 1 /* Actions.PUSH */]
  };
  pathStateMachine[4 /* States.IN_SUB_PATH */] = {
      ["'" /* PathCharTypes.SINGLE_QUOTE */]: [5 /* States.IN_SINGLE_QUOTE */, 0 /* Actions.APPEND */],
      ["\"" /* PathCharTypes.DOUBLE_QUOTE */]: [6 /* States.IN_DOUBLE_QUOTE */, 0 /* Actions.APPEND */],
      ["[" /* PathCharTypes.LEFT_BRACKET */]: [
          4 /* States.IN_SUB_PATH */,
          2 /* Actions.INC_SUB_PATH_DEPTH */
      ],
      ["]" /* PathCharTypes.RIGHT_BRACKET */]: [1 /* States.IN_PATH */, 3 /* Actions.PUSH_SUB_PATH */],
      ["o" /* PathCharTypes.END_OF_FAIL */]: 8 /* States.ERROR */,
      ["l" /* PathCharTypes.ELSE */]: [4 /* States.IN_SUB_PATH */, 0 /* Actions.APPEND */]
  };
  pathStateMachine[5 /* States.IN_SINGLE_QUOTE */] = {
      ["'" /* PathCharTypes.SINGLE_QUOTE */]: [4 /* States.IN_SUB_PATH */, 0 /* Actions.APPEND */],
      ["o" /* PathCharTypes.END_OF_FAIL */]: 8 /* States.ERROR */,
      ["l" /* PathCharTypes.ELSE */]: [5 /* States.IN_SINGLE_QUOTE */, 0 /* Actions.APPEND */]
  };
  pathStateMachine[6 /* States.IN_DOUBLE_QUOTE */] = {
      ["\"" /* PathCharTypes.DOUBLE_QUOTE */]: [4 /* States.IN_SUB_PATH */, 0 /* Actions.APPEND */],
      ["o" /* PathCharTypes.END_OF_FAIL */]: 8 /* States.ERROR */,
      ["l" /* PathCharTypes.ELSE */]: [6 /* States.IN_DOUBLE_QUOTE */, 0 /* Actions.APPEND */]
  };
  /**
   * Check if an expression is a literal value.
   */
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
      return literalValueRE.test(exp);
  }
  /**
   * Strip quotes from a string
   */
  function stripQuotes(str) {
      const a = str.charCodeAt(0);
      const b = str.charCodeAt(str.length - 1);
      return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
  }
  /**
   * Determine the type of a character in a keypath.
   */
  function getPathCharType(ch) {
      if (ch === undefined || ch === null) {
          return "o" /* PathCharTypes.END_OF_FAIL */;
      }
      const code = ch.charCodeAt(0);
      switch (code) {
          case 0x5b: // [
          case 0x5d: // ]
          case 0x2e: // .
          case 0x22: // "
          case 0x27: // '
              return ch;
          case 0x5f: // _
          case 0x24: // $
          case 0x2d: // -
              return "i" /* PathCharTypes.IDENT */;
          case 0x09: // Tab (HT)
          case 0x0a: // Newline (LF)
          case 0x0d: // Return (CR)
          case 0xa0: // No-break space (NBSP)
          case 0xfeff: // Byte Order Mark (BOM)
          case 0x2028: // Line Separator (LS)
          case 0x2029: // Paragraph Separator (PS)
              return "w" /* PathCharTypes.WORKSPACE */;
      }
      return "i" /* PathCharTypes.IDENT */;
  }
  /**
   * Format a subPath, return its plain form if it is
   * a literal string or number. Otherwise prepend the
   * dynamic indicator (*).
   */
  function formatSubPath(path) {
      const trimmed = path.trim();
      // invalid leading 0
      if (path.charAt(0) === '0' && isNaN(parseInt(path))) {
          return false;
      }
      return isLiteral(trimmed)
          ? stripQuotes(trimmed)
          : "*" /* PathCharTypes.ASTARISK */ + trimmed;
  }
  /**
   * Parse a string path into an array of segments
   */
  function parse(path) {
      const keys = [];
      let index = -1;
      let mode = 0 /* States.BEFORE_PATH */;
      let subPathDepth = 0;
      let c;
      let key; // eslint-disable-line
      let newChar;
      let type;
      let transition;
      let action;
      let typeMap;
      const actions = [];
      actions[0 /* Actions.APPEND */] = () => {
          if (key === undefined) {
              key = newChar;
          }
          else {
              key += newChar;
          }
      };
      actions[1 /* Actions.PUSH */] = () => {
          if (key !== undefined) {
              keys.push(key);
              key = undefined;
          }
      };
      actions[2 /* Actions.INC_SUB_PATH_DEPTH */] = () => {
          actions[0 /* Actions.APPEND */]();
          subPathDepth++;
      };
      actions[3 /* Actions.PUSH_SUB_PATH */] = () => {
          if (subPathDepth > 0) {
              subPathDepth--;
              mode = 4 /* States.IN_SUB_PATH */;
              actions[0 /* Actions.APPEND */]();
          }
          else {
              subPathDepth = 0;
              if (key === undefined) {
                  return false;
              }
              key = formatSubPath(key);
              if (key === false) {
                  return false;
              }
              else {
                  actions[1 /* Actions.PUSH */]();
              }
          }
      };
      function maybeUnescapeQuote() {
          const nextChar = path[index + 1];
          if ((mode === 5 /* States.IN_SINGLE_QUOTE */ &&
              nextChar === "'" /* PathCharTypes.SINGLE_QUOTE */) ||
              (mode === 6 /* States.IN_DOUBLE_QUOTE */ &&
                  nextChar === "\"" /* PathCharTypes.DOUBLE_QUOTE */)) {
              index++;
              newChar = '\\' + nextChar;
              actions[0 /* Actions.APPEND */]();
              return true;
          }
      }
      while (mode !== null) {
          index++;
          c = path[index];
          if (c === '\\' && maybeUnescapeQuote()) {
              continue;
          }
          type = getPathCharType(c);
          typeMap = pathStateMachine[mode];
          transition = typeMap[type] || typeMap["l" /* PathCharTypes.ELSE */] || 8 /* States.ERROR */;
          // check parse error
          if (transition === 8 /* States.ERROR */) {
              return;
          }
          mode = transition[0];
          if (transition[1] !== undefined) {
              action = actions[transition[1]];
              if (action) {
                  newChar = c;
                  if (action() === false) {
                      return;
                  }
              }
          }
          // check parse finish
          if (mode === 7 /* States.AFTER_PATH */) {
              return keys;
          }
      }
  }
  // path token cache
  const cache = new Map();
  /**
   * key-value message resolver
   *
   * @remarks
   * Resolves messages with the key-value structure. Note that messages with a hierarchical structure such as objects cannot be resolved
   *
   * @param obj - A target object to be resolved with path
   * @param path - A {@link Path | path} to resolve the value of message
   *
   * @returns A resolved {@link PathValue | path value}
   *
   * @VueI18nGeneral
   */
  function resolveWithKeyValue(obj, path) {
      return isObject(obj) ? obj[path] : null;
  }
  /**
   * message resolver
   *
   * @remarks
   * Resolves messages. messages with a hierarchical structure such as objects can be resolved. This resolver is used in VueI18n as default.
   *
   * @param obj - A target object to be resolved with path
   * @param path - A {@link Path | path} to resolve the value of message
   *
   * @returns A resolved {@link PathValue | path value}
   *
   * @VueI18nGeneral
   */
  function resolveValue(obj, path) {
      // check object
      if (!isObject(obj)) {
          return null;
      }
      // parse path
      let hit = cache.get(path);
      if (!hit) {
          hit = parse(path);
          if (hit) {
              cache.set(path, hit);
          }
      }
      // check hit
      if (!hit) {
          return null;
      }
      // resolve path value
      const len = hit.length;
      let last = obj;
      let i = 0;
      while (i < len) {
          const val = last[hit[i]];
          if (val === undefined) {
              return null;
          }
          if (isFunction(last)) {
              return null;
          }
          last = val;
          i++;
      }
      return last;
  }

  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => ''; // eslint-disable-line
  const DEFAULT_MESSAGE_DATA_TYPE = 'text';
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? '' : join(values);
  const DEFAULT_INTERPOLATE = toDisplayString;
  function pluralDefault(choice, choicesLength) {
      choice = Math.abs(choice);
      if (choicesLength === 2) {
          // prettier-ignore
          return choice
              ? choice > 1
                  ? 1
                  : 0
              : 1;
      }
      return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options) {
      // prettier-ignore
      const index = isNumber(options.pluralIndex)
          ? options.pluralIndex
          : -1;
      // prettier-ignore
      return options.named && (isNumber(options.named.count) || isNumber(options.named.n))
          ? isNumber(options.named.count)
              ? options.named.count
              : isNumber(options.named.n)
                  ? options.named.n
                  : index
          : index;
  }
  function normalizeNamed(pluralIndex, props) {
      if (!props.count) {
          props.count = pluralIndex;
      }
      if (!props.n) {
          props.n = pluralIndex;
      }
  }
  function createMessageContext(options = {}) {
      const locale = options.locale;
      const pluralIndex = getPluralIndex(options);
      const pluralRule = isObject(options.pluralRules) &&
          isString(locale) &&
          isFunction(options.pluralRules[locale])
          ? options.pluralRules[locale]
          : pluralDefault;
      const orgPluralRule = isObject(options.pluralRules) &&
          isString(locale) &&
          isFunction(options.pluralRules[locale])
          ? pluralDefault
          : undefined;
      const plural = (messages) => {
          return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
      };
      const _list = options.list || [];
      const list = (index) => _list[index];
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const _named = options.named || {};
      isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
      const named = (key) => _named[key];
      function message(key) {
          // prettier-ignore
          const msg = isFunction(options.messages)
              ? options.messages(key)
              : isObject(options.messages)
                  ? options.messages[key]
                  : false;
          return !msg
              ? options.parent
                  ? options.parent.message(key) // resolve from parent messages
                  : DEFAULT_MESSAGE
              : msg;
      }
      const _modifier = (name) => options.modifiers
          ? options.modifiers[name]
          : DEFAULT_MODIFIER;
      const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize)
          ? options.processor.normalize
          : DEFAULT_NORMALIZE;
      const interpolate = isPlainObject(options.processor) &&
          isFunction(options.processor.interpolate)
          ? options.processor.interpolate
          : DEFAULT_INTERPOLATE;
      const type = isPlainObject(options.processor) && isString(options.processor.type)
          ? options.processor.type
          : DEFAULT_MESSAGE_DATA_TYPE;
      const linked = (key, ...args) => {
          const [arg1, arg2] = args;
          let type = 'text';
          let modifier = '';
          if (args.length === 1) {
              if (isObject(arg1)) {
                  modifier = arg1.modifier || modifier;
                  type = arg1.type || type;
              }
              else if (isString(arg1)) {
                  modifier = arg1 || modifier;
              }
          }
          else if (args.length === 2) {
              if (isString(arg1)) {
                  modifier = arg1 || modifier;
              }
              if (isString(arg2)) {
                  type = arg2 || type;
              }
          }
          const ret = message(key)(ctx);
          const msg = 
          // The message in vnode resolved with linked are returned as an array by processor.nomalize
          type === 'vnode' && isArray(ret) && modifier
              ? ret[0]
              : ret;
          return modifier ? _modifier(modifier)(msg, type) : msg;
      };
      const ctx = {
          ["list" /* HelperNameMap.LIST */]: list,
          ["named" /* HelperNameMap.NAMED */]: named,
          ["plural" /* HelperNameMap.PLURAL */]: plural,
          ["linked" /* HelperNameMap.LINKED */]: linked,
          ["message" /* HelperNameMap.MESSAGE */]: message,
          ["type" /* HelperNameMap.TYPE */]: type,
          ["interpolate" /* HelperNameMap.INTERPOLATE */]: interpolate,
          ["normalize" /* HelperNameMap.NORMALIZE */]: normalize,
          ["values" /* HelperNameMap.VALUES */]: assign({}, _list, _named)
      };
      return ctx;
  }

  let devtools = null;
  function setDevToolsHook(hook) {
      devtools = hook;
  }
  function initI18nDevTools(i18n, version, meta) {
      // TODO: queue if devtools is undefined
      devtools &&
          devtools.emit("i18n:init" /* IntlifyDevToolsHooks.I18nInit */, {
              timestamp: Date.now(),
              i18n,
              version,
              meta
          });
  }
  const translateDevTools = /* #__PURE__*/ createDevToolsHook("function:translate" /* IntlifyDevToolsHooks.FunctionTranslate */);
  function createDevToolsHook(hook) {
      return (payloads) => devtools && devtools.emit(hook, payloads);
  }

  const code$3 = CompileWarnCodes.__EXTEND_POINT__;
  const inc$3 = incrementer(code$3);
  const CoreWarnCodes = {
      NOT_FOUND_KEY: code$3, // 2
      FALLBACK_TO_TRANSLATE: inc$3(), // 3
      CANNOT_FORMAT_NUMBER: inc$3(), // 4
      FALLBACK_TO_NUMBER_FORMAT: inc$3(), // 5
      CANNOT_FORMAT_DATE: inc$3(), // 6
      FALLBACK_TO_DATE_FORMAT: inc$3(), // 7
      EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$3(), // 8
      __EXTEND_POINT__: inc$3() // 9
  };
  /** @internal */
  const warnMessages$1 = {
      [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
      [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
      [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
      [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
      [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
      [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
      [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
  };
  function getWarnMessage$1(code, ...args) {
      return format(warnMessages$1[code], ...args);
  }

  const code$2 = CompileErrorCodes.__EXTEND_POINT__;
  const inc$2 = incrementer(code$2);
  const CoreErrorCodes = {
      INVALID_ARGUMENT: code$2, // 17
      INVALID_DATE_ARGUMENT: inc$2(), // 18
      INVALID_ISO_DATE_ARGUMENT: inc$2(), // 19
      NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(), // 20
      NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(), // 21
      NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(), // 22
      NOT_SUPPORT_LOCALE_TYPE: inc$2(), // 23
      __EXTEND_POINT__: inc$2() // 24
  };
  function createCoreError(code) {
      return createCompileError(code, null, { messages: errorMessages$1 } );
  }
  /** @internal */
  const errorMessages$1 = {
      [CoreErrorCodes.INVALID_ARGUMENT]: 'Invalid arguments',
      [CoreErrorCodes.INVALID_DATE_ARGUMENT]: 'The date provided is an invalid Date object.' +
          'Make sure your Date represents a valid date.',
      [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: 'The argument provided is not a valid ISO date string',
      [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: 'Not support non-string message',
      [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: 'cannot support promise value',
      [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: 'cannot support async function',
      [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: 'cannot support locale type'
  };

  /** @internal */
  function getLocale(context, options) {
      return options.locale != null
          ? resolveLocale(options.locale)
          : resolveLocale(context.locale);
  }
  let _resolveLocale;
  /** @internal */
  function resolveLocale(locale) {
      if (isString(locale)) {
          return locale;
      }
      else {
          if (isFunction(locale)) {
              if (locale.resolvedOnce && _resolveLocale != null) {
                  return _resolveLocale;
              }
              else if (locale.constructor.name === 'Function') {
                  const resolve = locale();
                  if (isPromise(resolve)) {
                      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
                  }
                  return (_resolveLocale = resolve);
              }
              else {
                  throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
              }
          }
          else {
              throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
          }
      }
  }
  /**
   * Fallback with simple implemenation
   *
   * @remarks
   * A fallback locale function implemented with a simple fallback algorithm.
   *
   * Basically, it returns the value as specified in the `fallbackLocale` props, and is processed with the fallback inside intlify.
   *
   * @param ctx - A {@link CoreContext | context}
   * @param fallback - A {@link FallbackLocale | fallback locale}
   * @param start - A starting {@link Locale | locale}
   *
   * @returns Fallback locales
   *
   * @VueI18nGeneral
   */
  function fallbackWithSimple(ctx, fallback, start // eslint-disable-line @typescript-eslint/no-unused-vars
  ) {
      // prettier-ignore
      return [...new Set([
              start,
              ...(isArray(fallback)
                  ? fallback
                  : isObject(fallback)
                      ? Object.keys(fallback)
                      : isString(fallback)
                          ? [fallback]
                          : [start])
          ])];
  }
  /**
   * Fallback with locale chain
   *
   * @remarks
   * A fallback locale function implemented with a fallback chain algorithm. It's used in VueI18n as default.
   *
   * @param ctx - A {@link CoreContext | context}
   * @param fallback - A {@link FallbackLocale | fallback locale}
   * @param start - A starting {@link Locale | locale}
   *
   * @returns Fallback locales
   *
   * @VueI18nSee [Fallbacking](../guide/essentials/fallback)
   *
   * @VueI18nGeneral
   */
  function fallbackWithLocaleChain(ctx, fallback, start) {
      const startLocale = isString(start) ? start : DEFAULT_LOCALE;
      const context = ctx;
      if (!context.__localeChainCache) {
          context.__localeChainCache = new Map();
      }
      let chain = context.__localeChainCache.get(startLocale);
      if (!chain) {
          chain = [];
          // first block defined by start
          let block = [start];
          // while any intervening block found
          while (isArray(block)) {
              block = appendBlockToChain(chain, block, fallback);
          }
          // prettier-ignore
          // last block defined by default
          const defaults = isArray(fallback) || !isPlainObject(fallback)
              ? fallback
              : fallback['default']
                  ? fallback['default']
                  : null;
          // convert defaults to array
          block = isString(defaults) ? [defaults] : defaults;
          if (isArray(block)) {
              appendBlockToChain(chain, block, false);
          }
          context.__localeChainCache.set(startLocale, chain);
      }
      return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
      let follow = true;
      for (let i = 0; i < block.length && isBoolean(follow); i++) {
          const locale = block[i];
          if (isString(locale)) {
              follow = appendLocaleToChain(chain, block[i], blocks);
          }
      }
      return follow;
  }
  function appendLocaleToChain(chain, locale, blocks) {
      let follow;
      const tokens = locale.split('-');
      do {
          const target = tokens.join('-');
          follow = appendItemToChain(chain, target, blocks);
          tokens.splice(-1, 1);
      } while (tokens.length && follow === true);
      return follow;
  }
  function appendItemToChain(chain, target, blocks) {
      let follow = false;
      if (!chain.includes(target)) {
          follow = true;
          if (target) {
              follow = target[target.length - 1] !== '!';
              const locale = target.replace(/!/g, '');
              chain.push(locale);
              if ((isArray(blocks) || isPlainObject(blocks)) &&
                  blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any
              ) {
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  follow = blocks[locale];
              }
          }
      }
      return follow;
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Intlify core-base version
   * @internal
   */
  const VERSION$1 = '9.13.1';
  const NOT_REOSLVED = -1;
  const DEFAULT_LOCALE = 'en-US';
  const MISSING_RESOLVE_VALUE = '';
  const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
  function getDefaultLinkedModifiers() {
      return {
          upper: (val, type) => {
              // prettier-ignore
              return type === 'text' && isString(val)
                  ? val.toUpperCase()
                  : type === 'vnode' && isObject(val) && '__v_isVNode' in val
                      ? val.children.toUpperCase()
                      : val;
          },
          lower: (val, type) => {
              // prettier-ignore
              return type === 'text' && isString(val)
                  ? val.toLowerCase()
                  : type === 'vnode' && isObject(val) && '__v_isVNode' in val
                      ? val.children.toLowerCase()
                      : val;
          },
          capitalize: (val, type) => {
              // prettier-ignore
              return (type === 'text' && isString(val)
                  ? capitalize(val)
                  : type === 'vnode' && isObject(val) && '__v_isVNode' in val
                      ? capitalize(val.children)
                      : val);
          }
      };
  }
  let _compiler;
  let _resolver;
  /**
   * Register the message resolver
   *
   * @param resolver - A {@link MessageResolver} function
   *
   * @VueI18nGeneral
   */
  function registerMessageResolver(resolver) {
      _resolver = resolver;
  }
  let _fallbacker;
  /**
   * Register the locale fallbacker
   *
   * @param fallbacker - A {@link LocaleFallbacker} function
   *
   * @VueI18nGeneral
   */
  function registerLocaleFallbacker(fallbacker) {
      _fallbacker = fallbacker;
  }
  // Additional Meta for Intlify DevTools
  let _additionalMeta =  null;
  /* #__NO_SIDE_EFFECTS__ */
  const setAdditionalMeta = (meta) => {
      _additionalMeta = meta;
  };
  /* #__NO_SIDE_EFFECTS__ */
  const getAdditionalMeta = () => _additionalMeta;
  let _fallbackContext = null;
  const setFallbackContext = (context) => {
      _fallbackContext = context;
  };
  const getFallbackContext = () => _fallbackContext;
  // ID for CoreContext
  let _cid = 0;
  function createCoreContext(options = {}) {
      // setup options
      const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
      const version = isString(options.version) ? options.version : VERSION$1;
      const locale = isString(options.locale) || isFunction(options.locale)
          ? options.locale
          : DEFAULT_LOCALE;
      const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
      const fallbackLocale = isArray(options.fallbackLocale) ||
          isPlainObject(options.fallbackLocale) ||
          isString(options.fallbackLocale) ||
          options.fallbackLocale === false
          ? options.fallbackLocale
          : _locale;
      const messages = isPlainObject(options.messages)
          ? options.messages
          : { [_locale]: {} };
      const datetimeFormats = isPlainObject(options.datetimeFormats)
              ? options.datetimeFormats
              : { [_locale]: {} }
          ;
      const numberFormats = isPlainObject(options.numberFormats)
              ? options.numberFormats
              : { [_locale]: {} }
          ;
      const modifiers = assign({}, options.modifiers || {}, getDefaultLinkedModifiers());
      const pluralRules = options.pluralRules || {};
      const missing = isFunction(options.missing) ? options.missing : null;
      const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn)
          ? options.missingWarn
          : true;
      const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn)
          ? options.fallbackWarn
          : true;
      const fallbackFormat = !!options.fallbackFormat;
      const unresolving = !!options.unresolving;
      const postTranslation = isFunction(options.postTranslation)
          ? options.postTranslation
          : null;
      const processor = isPlainObject(options.processor) ? options.processor : null;
      const warnHtmlMessage = isBoolean(options.warnHtmlMessage)
          ? options.warnHtmlMessage
          : true;
      const escapeParameter = !!options.escapeParameter;
      const messageCompiler = isFunction(options.messageCompiler)
          ? options.messageCompiler
          : _compiler;
      const messageResolver = isFunction(options.messageResolver)
          ? options.messageResolver
          : _resolver || resolveWithKeyValue;
      const localeFallbacker = isFunction(options.localeFallbacker)
          ? options.localeFallbacker
          : _fallbacker || fallbackWithSimple;
      const fallbackContext = isObject(options.fallbackContext)
          ? options.fallbackContext
          : undefined;
      // setup internal options
      const internalOptions = options;
      const __datetimeFormatters = isObject(internalOptions.__datetimeFormatters)
              ? internalOptions.__datetimeFormatters
              : new Map()
          ;
      const __numberFormatters = isObject(internalOptions.__numberFormatters)
              ? internalOptions.__numberFormatters
              : new Map()
          ;
      const __meta = isObject(internalOptions.__meta) ? internalOptions.__meta : {};
      _cid++;
      const context = {
          version,
          cid: _cid,
          locale,
          fallbackLocale,
          messages,
          modifiers,
          pluralRules,
          missing,
          missingWarn,
          fallbackWarn,
          fallbackFormat,
          unresolving,
          postTranslation,
          processor,
          warnHtmlMessage,
          escapeParameter,
          messageCompiler,
          messageResolver,
          localeFallbacker,
          fallbackContext,
          onWarn,
          __meta
      };
      {
          context.datetimeFormats = datetimeFormats;
          context.numberFormats = numberFormats;
          context.__datetimeFormatters = __datetimeFormatters;
          context.__numberFormatters = __numberFormatters;
      }
      // NOTE: experimental !!
      {
          initI18nDevTools(context, version, __meta);
      }
      return context;
  }
  /** @internal */
  function isTranslateFallbackWarn(fallback, key) {
      return fallback instanceof RegExp ? fallback.test(key) : fallback;
  }
  /** @internal */
  function isTranslateMissingWarn(missing, key) {
      return missing instanceof RegExp ? missing.test(key) : missing;
  }
  /** @internal */
  function handleMissing(context, key, locale, missingWarn, type) {
      const { missing, onWarn } = context;
      if (missing !== null) {
          const ret = missing(context, locale, key, type);
          return isString(ret) ? ret : key;
      }
      else {
          if (isTranslateMissingWarn(missingWarn, key)) {
              onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, { key, locale }));
          }
          return key;
      }
  }
  /** @internal */
  function updateFallbackLocale(ctx, locale, fallback) {
      const context = ctx;
      context.__localeChainCache = new Map();
      ctx.localeFallbacker(ctx, fallback, locale);
  }
  /** @internal */
  function isAlmostSameLocale(locale, compareLocale) {
      if (locale === compareLocale)
          return false;
      return locale.split('-')[0] === compareLocale.split('-')[0];
  }
  /** @internal */
  function isImplicitFallback(targetLocale, locales) {
      const index = locales.indexOf(targetLocale);
      if (index === -1) {
          return false;
      }
      for (let i = index + 1; i < locales.length; i++) {
          if (isAlmostSameLocale(targetLocale, locales[i])) {
              return true;
          }
      }
      return false;
  }
  /* eslint-enable @typescript-eslint/no-explicit-any */

  const isMessageAST = (val) => isObject(val) &&
      (val.t === 0 || val.type === 0) &&
      ('b' in val || 'body' in val);

  const NOOP_MESSAGE_FUNCTION = () => '';
  const isMessageFunction = (val) => isFunction(val);
  // implementation of `translate` function
  function translate(context, ...args) {
      const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
      const [key, options] = parseTranslateArgs(...args);
      const missingWarn = isBoolean(options.missingWarn)
          ? options.missingWarn
          : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn)
          ? options.fallbackWarn
          : context.fallbackWarn;
      const escapeParameter = isBoolean(options.escapeParameter)
          ? options.escapeParameter
          : context.escapeParameter;
      const resolvedMessage = !!options.resolvedMessage;
      // prettier-ignore
      const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) // default by function option
          ? !isBoolean(options.default)
              ? options.default
              : (!messageCompiler ? () => key : key)
          : fallbackFormat // default by `fallbackFormat` option
              ? (!messageCompiler ? () => key : key)
              : '';
      const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== '';
      const locale = getLocale(context, options);
      // escape params
      escapeParameter && escapeParams(options);
      // resolve message format
      // eslint-disable-next-line prefer-const
      let [formatScope, targetLocale, message] = !resolvedMessage
          ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn)
          : [
              key,
              locale,
              messages[locale] || {}
          ];
      // NOTE:
      //  Fix to work around `ssrTransfrom` bug in Vite.
      //  https://github.com/vitejs/vite/issues/4306
      //  To get around this, use temporary variables.
      //  https://github.com/nuxt/framework/issues/1461#issuecomment-954606243
      let format = formatScope;
      // if you use default message, set it as message format!
      let cacheBaseKey = key;
      if (!resolvedMessage &&
          !(isString(format) ||
              isMessageAST(format) ||
              isMessageFunction(format))) {
          if (enableDefaultMsg) {
              format = defaultMsgOrKey;
              cacheBaseKey = format;
          }
      }
      // checking message format and target locale
      if (!resolvedMessage &&
          (!(isString(format) ||
              isMessageAST(format) ||
              isMessageFunction(format)) ||
              !isString(targetLocale))) {
          return unresolving ? NOT_REOSLVED : key;
      }
      // TODO: refactor
      if (isString(format) && context.messageCompiler == null) {
          warn(`The message format compilation is not supported in this build. ` +
              `Because message compiler isn't included. ` +
              `You need to pre-compilation all message format. ` +
              `So translate function return '${key}'.`);
          return key;
      }
      // setup compile error detecting
      let occurred = false;
      const onError = () => {
          occurred = true;
      };
      // compile message format
      const msg = !isMessageFunction(format)
          ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, onError)
          : format;
      // if occurred compile error, return the message format
      if (occurred) {
          return format;
      }
      // evaluate message with context
      const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
      const msgContext = createMessageContext(ctxOptions);
      const messaged = evaluateMessage(context, msg, msgContext);
      // if use post translation option, proceed it with handler
      const ret = postTranslation
          ? postTranslation(messaged, key)
          : messaged;
      // NOTE: experimental !!
      {
          // prettier-ignore
          const payloads = {
              timestamp: Date.now(),
              key: isString(key)
                  ? key
                  : isMessageFunction(format)
                      ? format.key
                      : '',
              locale: targetLocale || (isMessageFunction(format)
                  ? format.locale
                  : ''),
              format: isString(format)
                  ? format
                  : isMessageFunction(format)
                      ? format.source
                      : '',
              message: ret
          };
          payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
          translateDevTools(payloads);
      }
      return ret;
  }
  function escapeParams(options) {
      if (isArray(options.list)) {
          options.list = options.list.map(item => isString(item) ? escapeHtml(item) : item);
      }
      else if (isObject(options.named)) {
          Object.keys(options.named).forEach(key => {
              if (isString(options.named[key])) {
                  options.named[key] = escapeHtml(options.named[key]);
              }
          });
      }
  }
  function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
      const { messages, onWarn, messageResolver: resolveValue, localeFallbacker } = context;
      const locales = localeFallbacker(context, fallbackLocale, locale); // eslint-disable-line @typescript-eslint/no-explicit-any
      let message = {};
      let targetLocale;
      let format = null;
      const type = 'translate';
      for (let i = 0; i < locales.length; i++) {
          targetLocale = locales[i];
          if (locale !== targetLocale &&
              !isAlmostSameLocale(locale, targetLocale) &&
              isTranslateFallbackWarn(fallbackWarn, key)) {
              onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
                  key,
                  target: targetLocale
              }));
          }
          message =
              messages[targetLocale] || {};
          let startTag;
          if (inBrowser) {
              window.performance.now();
              startTag = 'intlify-message-resolve-start';
              mark && mark(startTag);
          }
          if ((format = resolveValue(message, key)) === null) {
              // if null, resolve with object key path
              format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any
          }
          if (isString(format) || isMessageAST(format) || isMessageFunction(format)) {
              break;
          }
          if (!isImplicitFallback(targetLocale, locales)) {
              const missingRet = handleMissing(context, // eslint-disable-line @typescript-eslint/no-explicit-any
              key, targetLocale, missingWarn, type);
              if (missingRet !== key) {
                  format = missingRet;
              }
          }
      }
      return [format, targetLocale, message];
  }
  function compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, onError) {
      const { messageCompiler, warnHtmlMessage } = context;
      if (isMessageFunction(format)) {
          const msg = format;
          msg.locale = msg.locale || targetLocale;
          msg.key = msg.key || key;
          return msg;
      }
      if (messageCompiler == null) {
          const msg = (() => format);
          msg.locale = targetLocale;
          msg.key = key;
          return msg;
      }
      let startTag;
      if (inBrowser) {
          window.performance.now();
          startTag = 'intlify-message-compilation-start';
          mark && mark(startTag);
      }
      const msg = messageCompiler(format, getCompileContext(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, onError));
      msg.locale = targetLocale;
      msg.key = key;
      msg.source = format;
      return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
      let startTag;
      if (inBrowser) {
          window.performance.now();
          startTag = 'intlify-message-evaluation-start';
          mark && mark(startTag);
      }
      const messaged = msg(msgCtx);
      return messaged;
  }
  /** @internal */
  function parseTranslateArgs(...args) {
      const [arg1, arg2, arg3] = args;
      const options = {};
      if (!isString(arg1) &&
          !isNumber(arg1) &&
          !isMessageFunction(arg1) &&
          !isMessageAST(arg1)) {
          throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      // prettier-ignore
      const key = isNumber(arg1)
          ? String(arg1)
          : isMessageFunction(arg1)
              ? arg1
              : arg1;
      if (isNumber(arg2)) {
          options.plural = arg2;
      }
      else if (isString(arg2)) {
          options.default = arg2;
      }
      else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
          options.named = arg2;
      }
      else if (isArray(arg2)) {
          options.list = arg2;
      }
      if (isNumber(arg3)) {
          options.plural = arg3;
      }
      else if (isString(arg3)) {
          options.default = arg3;
      }
      else if (isPlainObject(arg3)) {
          assign(options, arg3);
      }
      return [key, options];
  }
  function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
      return {
          locale,
          key,
          warnHtmlMessage,
          onError: (err) => {
              onError && onError(err);
              {
                  throw err;
              }
          },
          onCacheKey: (source) => generateFormatCacheKey(locale, key, source)
      };
  }
  function getMessageContextOptions(context, locale, message, options) {
      const { modifiers, pluralRules, messageResolver: resolveValue, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
      const resolveMessage = (key) => {
          let val = resolveValue(message, key);
          // fallback to root context
          if (val == null && fallbackContext) {
              const [, , message] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
              val = resolveValue(message, key);
          }
          if (isString(val) || isMessageAST(val)) {
              let occurred = false;
              const onError = () => {
                  occurred = true;
              };
              const msg = compileMessageFormat(context, key, locale, val, key, onError);
              return !occurred
                  ? msg
                  : NOOP_MESSAGE_FUNCTION;
          }
          else if (isMessageFunction(val)) {
              return val;
          }
          else {
              // TODO: should be implemented warning message
              return NOOP_MESSAGE_FUNCTION;
          }
      };
      const ctxOptions = {
          locale,
          modifiers,
          pluralRules,
          messages: resolveMessage
      };
      if (context.processor) {
          ctxOptions.processor = context.processor;
      }
      if (options.list) {
          ctxOptions.list = options.list;
      }
      if (options.named) {
          ctxOptions.named = options.named;
      }
      if (isNumber(options.plural)) {
          ctxOptions.pluralIndex = options.plural;
      }
      return ctxOptions;
  }

  const intlDefined = typeof Intl !== 'undefined';
  const Availabilities = {
      dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
      numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
  };

  // implementation of `datetime` function
  function datetime(context, ...args) {
      const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
      const { __datetimeFormatters } = context;
      if (!Availabilities.dateTimeFormat) {
          onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
          return MISSING_RESOLVE_VALUE;
      }
      const [key, value, options, overrides] = parseDateTimeArgs(...args);
      const missingWarn = isBoolean(options.missingWarn)
          ? options.missingWarn
          : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn)
          ? options.fallbackWarn
          : context.fallbackWarn;
      const part = !!options.part;
      const locale = getLocale(context, options);
      const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
      fallbackLocale, locale);
      if (!isString(key) || key === '') {
          return new Intl.DateTimeFormat(locale, overrides).format(value);
      }
      // resolve format
      let datetimeFormat = {};
      let targetLocale;
      let format = null;
      const type = 'datetime format';
      for (let i = 0; i < locales.length; i++) {
          targetLocale = locales[i];
          if (locale !== targetLocale &&
              isTranslateFallbackWarn(fallbackWarn, key)) {
              onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
                  key,
                  target: targetLocale
              }));
          }
          datetimeFormat =
              datetimeFormats[targetLocale] || {};
          format = datetimeFormat[key];
          if (isPlainObject(format))
              break;
          handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any
      }
      // checking format and target locale
      if (!isPlainObject(format) || !isString(targetLocale)) {
          return unresolving ? NOT_REOSLVED : key;
      }
      let id = `${targetLocale}__${key}`;
      if (!isEmptyObject(overrides)) {
          id = `${id}__${JSON.stringify(overrides)}`;
      }
      let formatter = __datetimeFormatters.get(id);
      if (!formatter) {
          formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format, overrides));
          __datetimeFormatters.set(id, formatter);
      }
      return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  /** @internal */
  const DATETIME_FORMAT_OPTIONS_KEYS = [
      'localeMatcher',
      'weekday',
      'era',
      'year',
      'month',
      'day',
      'hour',
      'minute',
      'second',
      'timeZoneName',
      'formatMatcher',
      'hour12',
      'timeZone',
      'dateStyle',
      'timeStyle',
      'calendar',
      'dayPeriod',
      'numberingSystem',
      'hourCycle',
      'fractionalSecondDigits'
  ];
  /** @internal */
  function parseDateTimeArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;
      const options = {};
      let overrides = {};
      let value;
      if (isString(arg1)) {
          // Only allow ISO strings - other date formats are often supported,
          // but may cause different results in different browsers.
          const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
          if (!matches) {
              throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
          }
          // Some browsers can not parse the iso datetime separated by space,
          // this is a compromise solution by replace the 'T'/' ' with 'T'
          const dateTime = matches[3]
              ? matches[3].trim().startsWith('T')
                  ? `${matches[1].trim()}${matches[3].trim()}`
                  : `${matches[1].trim()}T${matches[3].trim()}`
              : matches[1].trim();
          value = new Date(dateTime);
          try {
              // This will fail if the date is not valid
              value.toISOString();
          }
          catch (e) {
              throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
          }
      }
      else if (isDate(arg1)) {
          if (isNaN(arg1.getTime())) {
              throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
          }
          value = arg1;
      }
      else if (isNumber(arg1)) {
          value = arg1;
      }
      else {
          throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      if (isString(arg2)) {
          options.key = arg2;
      }
      else if (isPlainObject(arg2)) {
          Object.keys(arg2).forEach(key => {
              if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
                  overrides[key] = arg2[key];
              }
              else {
                  options[key] = arg2[key];
              }
          });
      }
      if (isString(arg3)) {
          options.locale = arg3;
      }
      else if (isPlainObject(arg3)) {
          overrides = arg3;
      }
      if (isPlainObject(arg4)) {
          overrides = arg4;
      }
      return [options.key || '', value, options, overrides];
  }
  /** @internal */
  function clearDateTimeFormat(ctx, locale, format) {
      const context = ctx;
      for (const key in format) {
          const id = `${locale}__${key}`;
          if (!context.__datetimeFormatters.has(id)) {
              continue;
          }
          context.__datetimeFormatters.delete(id);
      }
  }

  // implementation of `number` function
  function number(context, ...args) {
      const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
      const { __numberFormatters } = context;
      if (!Availabilities.numberFormat) {
          onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
          return MISSING_RESOLVE_VALUE;
      }
      const [key, value, options, overrides] = parseNumberArgs(...args);
      const missingWarn = isBoolean(options.missingWarn)
          ? options.missingWarn
          : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn)
          ? options.fallbackWarn
          : context.fallbackWarn;
      const part = !!options.part;
      const locale = getLocale(context, options);
      const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
      fallbackLocale, locale);
      if (!isString(key) || key === '') {
          return new Intl.NumberFormat(locale, overrides).format(value);
      }
      // resolve format
      let numberFormat = {};
      let targetLocale;
      let format = null;
      const type = 'number format';
      for (let i = 0; i < locales.length; i++) {
          targetLocale = locales[i];
          if (locale !== targetLocale &&
              isTranslateFallbackWarn(fallbackWarn, key)) {
              onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
                  key,
                  target: targetLocale
              }));
          }
          numberFormat =
              numberFormats[targetLocale] || {};
          format = numberFormat[key];
          if (isPlainObject(format))
              break;
          handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any
      }
      // checking format and target locale
      if (!isPlainObject(format) || !isString(targetLocale)) {
          return unresolving ? NOT_REOSLVED : key;
      }
      let id = `${targetLocale}__${key}`;
      if (!isEmptyObject(overrides)) {
          id = `${id}__${JSON.stringify(overrides)}`;
      }
      let formatter = __numberFormatters.get(id);
      if (!formatter) {
          formatter = new Intl.NumberFormat(targetLocale, assign({}, format, overrides));
          __numberFormatters.set(id, formatter);
      }
      return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  /** @internal */
  const NUMBER_FORMAT_OPTIONS_KEYS = [
      'localeMatcher',
      'style',
      'currency',
      'currencyDisplay',
      'currencySign',
      'useGrouping',
      'minimumIntegerDigits',
      'minimumFractionDigits',
      'maximumFractionDigits',
      'minimumSignificantDigits',
      'maximumSignificantDigits',
      'compactDisplay',
      'notation',
      'signDisplay',
      'unit',
      'unitDisplay',
      'roundingMode',
      'roundingPriority',
      'roundingIncrement',
      'trailingZeroDisplay'
  ];
  /** @internal */
  function parseNumberArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;
      const options = {};
      let overrides = {};
      if (!isNumber(arg1)) {
          throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      const value = arg1;
      if (isString(arg2)) {
          options.key = arg2;
      }
      else if (isPlainObject(arg2)) {
          Object.keys(arg2).forEach(key => {
              if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
                  overrides[key] = arg2[key];
              }
              else {
                  options[key] = arg2[key];
              }
          });
      }
      if (isString(arg3)) {
          options.locale = arg3;
      }
      else if (isPlainObject(arg3)) {
          overrides = arg3;
      }
      if (isPlainObject(arg4)) {
          overrides = arg4;
      }
      return [options.key || '', value, options, overrides];
  }
  /** @internal */
  function clearNumberFormat(ctx, locale, format) {
      const context = ctx;
      for (const key in format) {
          const id = `${locale}__${key}`;
          if (!context.__numberFormatters.has(id)) {
              continue;
          }
          context.__numberFormatters.delete(id);
      }
  }

  /**
   * Vue I18n Version
   *
   * @remarks
   * Semver format. Same format as the package.json `version` field.
   *
   * @VueI18nGeneral
   */
  const VERSION = '9.13.1';
  /**
   * This is only called development env
   * istanbul-ignore-next
   */
  function initDev() {
      {
          {
              console.info(`You are running a development build of vue-i18n.\n` +
                  `Make sure to use the production build (*.prod.js) when deploying for production.`);
          }
      }
      {
          console.warn(`vue-i18n-bridge v10 will not be released, since vue-i18n-bridge is for Vue 2, which is already past EOL.`);
      }
  }

  const code$1 = CoreWarnCodes.__EXTEND_POINT__;
  const inc$1 = incrementer(code$1);
  const I18nWarnCodes = {
      FALLBACK_TO_ROOT: code$1, // 9
      NOT_SUPPORTED_PRESERVE: inc$1(), // 10
      NOT_SUPPORTED_FORMATTER: inc$1(), // 11
      NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(), // 12
      NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(), // 13
      COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(), // 14
      NOT_FOUND_PARENT_SCOPE: inc$1(), // 15
      IGNORE_OBJ_FLATTEN: inc$1(), // 16
      NOTICE_DROP_ALLOW_COMPOSITION: inc$1(), // 17
      NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1() // 18
  };
  const warnMessages = {
      [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
      [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
      [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
      [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
      [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
      [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
      [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
      [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
      [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze`,
      [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
  };
  function getWarnMessage(code, ...args) {
      return format(warnMessages[code], ...args);
  }

  const code = CoreErrorCodes.__EXTEND_POINT__;
  const inc = incrementer(code);
  const I18nErrorCodes = {
      // composer module errors
      UNEXPECTED_RETURN_TYPE: code, // 24
      // legacy module errors
      INVALID_ARGUMENT: inc(), // 25
      // i18n module errors
      MUST_BE_CALL_SETUP_TOP: inc(), // 26
      NOT_INSTALLED: inc(), // 27
      NOT_AVAILABLE_IN_LEGACY_MODE: inc(), // 28
      // directive module errors
      REQUIRED_VALUE: inc(), // 29
      INVALID_VALUE: inc(), // 30
      // vue-devtools errors
      CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(), // 31
      NOT_INSTALLED_WITH_PROVIDE: inc(), // 32
      // unexpected error
      UNEXPECTED_ERROR: inc(), // 33
      // not compatible legacy vue-i18n constructor
      NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(), // 34
      // bridge support vue 2.x only
      BRIDGE_SUPPORT_VUE_2_ONLY: inc(), // 35
      // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
      MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(), // 36
      // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
      NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(), // 37
      // for enhancement
      __EXTEND_POINT__: inc() // 38
  };
  function createI18nError(code, ...args) {
      return createCompileError(code, null, { messages: errorMessages, args } );
  }
  const errorMessages = {
      [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: 'Unexpected return type in composer',
      [I18nErrorCodes.INVALID_ARGUMENT]: 'Invalid argument',
      [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: 'Must be called at the top of a `setup` function',
      [I18nErrorCodes.NOT_INSTALLED]: 'Need to install with `app.use` function',
      [I18nErrorCodes.UNEXPECTED_ERROR]: 'Unexpected error',
      [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: 'Not available in legacy mode',
      [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
      [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
      [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
      [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: 'Need to install with `provide` function',
      [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: 'Not compatible legacy VueI18n.',
      [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: 'vue-i18n-bridge support Vue 2.x only',
      [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: 'Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode',
      [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: 'Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly'
  };

  const TranslateVNodeSymbol = 
  /* #__PURE__*/ makeSymbol('__translateVNode');
  const DatetimePartsSymbol = /* #__PURE__*/ makeSymbol('__datetimeParts');
  const NumberPartsSymbol = /* #__PURE__*/ makeSymbol('__numberParts');
  const SetPluralRulesSymbol = makeSymbol('__setPluralRules');
  const LegacyInstanceSymbol = /* #__PURE__*/ makeSymbol('__legacyVueI18n');
  const InejctWithOptionSymbol = 
  /* #__PURE__*/ makeSymbol('__injectWithOption');
  const DisposeSymbol = /* #__PURE__*/ makeSymbol('__dispose');
  const __VUE_I18N_BRIDGE__ =  '__VUE_I18N_BRIDGE__';

  /* eslint-disable @typescript-eslint/no-explicit-any */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function isLegacyVueI18n(VueI18n) {
      if (VueI18n == null || VueI18n.version == null) {
          return false;
      }
      return (Number(VueI18n.version.split('.')[0]) || -1) >= 8;
  }
  /**
   * Transform flat json in obj to normal json in obj
   */
  function handleFlatJson(obj) {
      // check obj
      if (!isObject(obj)) {
          return obj;
      }
      for (const key in obj) {
          // check key
          if (!hasOwn(obj, key)) {
              continue;
          }
          // handle for normal json
          if (!key.includes('.')) {
              // recursive process value if value is also a object
              if (isObject(obj[key])) {
                  handleFlatJson(obj[key]);
              }
          }
          // handle for flat json, transform to normal json
          else {
              // go to the last object
              const subKeys = key.split('.');
              const lastIndex = subKeys.length - 1;
              let currentObj = obj;
              let hasStringValue = false;
              for (let i = 0; i < lastIndex; i++) {
                  if (!(subKeys[i] in currentObj)) {
                      currentObj[subKeys[i]] = {};
                  }
                  if (!isObject(currentObj[subKeys[i]])) {
                      warn(getWarnMessage(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {
                              key: subKeys[i]
                          }));
                      hasStringValue = true;
                      break;
                  }
                  currentObj = currentObj[subKeys[i]];
              }
              // update last object value, delete old property
              if (!hasStringValue) {
                  currentObj[subKeys[lastIndex]] = obj[key];
                  delete obj[key];
              }
              // recursive process value if value is also a object
              if (isObject(currentObj[subKeys[lastIndex]])) {
                  handleFlatJson(currentObj[subKeys[lastIndex]]);
              }
          }
      }
      return obj;
  }
  function getLocaleMessages(locale, options) {
      const { messages, __i18n, messageResolver, flatJson } = options;
      // prettier-ignore
      const ret = (isPlainObject(messages)
          ? messages
          : isArray(__i18n)
              ? {}
              : { [locale]: {} });
      // merge locale messages of i18n custom block
      if (isArray(__i18n)) {
          __i18n.forEach(custom => {
              if ('locale' in custom && 'resource' in custom) {
                  const { locale, resource } = custom;
                  if (locale) {
                      ret[locale] = ret[locale] || {};
                      deepCopy(resource, ret[locale]);
                  }
                  else {
                      deepCopy(resource, ret);
                  }
              }
              else {
                  isString(custom) && deepCopy(JSON.parse(custom), ret);
              }
          });
      }
      // handle messages for flat json
      if (messageResolver == null && flatJson) {
          for (const key in ret) {
              if (hasOwn(ret, key)) {
                  handleFlatJson(ret[key]);
              }
          }
      }
      return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function getComponentOptions(instance) {
      return instance.proxy.$options;
  }
  function adjustI18nResources(gl, options, componentOptions // eslint-disable-line @typescript-eslint/no-explicit-any
  ) {
      let messages = isObject(options.messages) ? options.messages : {};
      if ('__i18nGlobal' in componentOptions) {
          messages = getLocaleMessages(gl.locale.value, {
              messages,
              __i18n: componentOptions.__i18nGlobal
          });
      }
      // merge locale messages
      const locales = Object.keys(messages);
      if (locales.length) {
          locales.forEach(locale => {
              gl.mergeLocaleMessage(locale, messages[locale]);
          });
      }
      {
          // merge datetime formats
          if (isObject(options.datetimeFormats)) {
              const locales = Object.keys(options.datetimeFormats);
              if (locales.length) {
                  locales.forEach(locale => {
                      gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
                  });
              }
          }
          // merge number formats
          if (isObject(options.numberFormats)) {
              const locales = Object.keys(options.numberFormats);
              if (locales.length) {
                  locales.forEach(locale => {
                      gl.mergeNumberFormat(locale, options.numberFormats[locale]);
                  });
              }
          }
      }
  }
  function createTextNode(key) {
      return createVNodeVue2Compatible(key);
  }
  function createVNodeVue2Compatible(key) {
      // shim Vue2 VNode interface
      // see the https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js
      const componentInstance = undefined;
      return {
          tag: undefined,
          data: undefined,
          children: undefined,
          text: key,
          elm: undefined,
          ns: undefined,
          context: undefined,
          fnContext: undefined,
          fnOptions: undefined,
          fnScopeId: undefined,
          key: undefined,
          componentOptions: undefined,
          componentInstance,
          parent: undefined,
          raw: false,
          isStatic: false,
          isRootInsert: true,
          isComment: false,
          isCloned: false,
          isOnce: false,
          asyncFactory: undefined,
          asyncMeta: undefined,
          isAsyncPlaceholder: false,
          child: () => componentInstance
      };
  }
  /* eslint-enable @typescript-eslint/no-explicit-any */

  /* eslint-disable @typescript-eslint/no-explicit-any */
  // extend VNode interface
  const DEVTOOLS_META = '__INTLIFY_META__';
  const NOOP_RETURN_ARRAY = () => [];
  const NOOP_RETURN_FALSE = () => false;
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
      return ((ctx, locale, key, type) => {
          return missing(locale, key, vueDemi.getCurrentInstance() || undefined, type);
      });
  }
  // for Intlify DevTools
  /* #__NO_SIDE_EFFECTS__ */
  const getMetaInfo = () => {
      const instance = vueDemi.getCurrentInstance();
      let meta = null; // eslint-disable-line @typescript-eslint/no-explicit-any
      return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META])
          ? { [DEVTOOLS_META]: meta } // eslint-disable-line @typescript-eslint/no-explicit-any
          : null;
  };
  /**
   * Create composer interface factory
   *
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function createComposer(options = {}, VueI18nLegacy) {
      const { __root, __injectWithOption } = options;
      const _isGlobal = __root === undefined;
      const flatJson = options.flatJson;
      const _ref = inBrowser ? vueDemi.ref : vueDemi.shallowRef;
      const translateExistCompatible = !!options.translateExistCompatible;
      {
          if (translateExistCompatible && !false) {
              warnOnce(getWarnMessage(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
          }
      }
      let _inheritLocale = isBoolean(options.inheritLocale)
          ? options.inheritLocale
          : true;
      const _locale = _ref(
      // prettier-ignore
      __root && _inheritLocale
          ? __root.locale.value
          : isString(options.locale)
              ? options.locale
              : DEFAULT_LOCALE);
      const _fallbackLocale = _ref(
      // prettier-ignore
      __root && _inheritLocale
          ? __root.fallbackLocale.value
          : isString(options.fallbackLocale) ||
              isArray(options.fallbackLocale) ||
              isPlainObject(options.fallbackLocale) ||
              options.fallbackLocale === false
              ? options.fallbackLocale
              : _locale.value);
      const _messages = _ref(getLocaleMessages(_locale.value, options));
      // prettier-ignore
      const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats)
              ? options.datetimeFormats
              : { [_locale.value]: {} })
          ;
      // prettier-ignore
      const _numberFormats = _ref(isPlainObject(options.numberFormats)
              ? options.numberFormats
              : { [_locale.value]: {} })
          ;
      // warning suppress options
      // prettier-ignore
      let _missingWarn = __root
          ? __root.missingWarn
          : isBoolean(options.missingWarn) || isRegExp(options.missingWarn)
              ? options.missingWarn
              : true;
      // prettier-ignore
      let _fallbackWarn = __root
          ? __root.fallbackWarn
          : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn)
              ? options.fallbackWarn
              : true;
      // prettier-ignore
      let _fallbackRoot = __root
          ? __root.fallbackRoot
          : isBoolean(options.fallbackRoot)
              ? options.fallbackRoot
              : true;
      // configure fall back to root
      let _fallbackFormat = !!options.fallbackFormat;
      // runtime missing
      let _missing = isFunction(options.missing) ? options.missing : null;
      let _runtimeMissing = isFunction(options.missing)
          ? defineCoreMissingHandler(options.missing)
          : null;
      // postTranslation handler
      let _postTranslation = isFunction(options.postTranslation)
          ? options.postTranslation
          : null;
      // prettier-ignore
      let _warnHtmlMessage = __root
          ? __root.warnHtmlMessage
          : isBoolean(options.warnHtmlMessage)
              ? options.warnHtmlMessage
              : true;
      let _escapeParameter = !!options.escapeParameter;
      // custom linked modifiers
      // prettier-ignore
      const _modifiers = __root
          ? __root.modifiers
          : isPlainObject(options.modifiers)
              ? options.modifiers
              : {};
      // pluralRules
      let _pluralRules = options.pluralRules || (__root && __root.pluralRules);
      // for bridge
      let __legacy;
      {
          if (!isLegacyVueI18n(VueI18nLegacy)) {
              createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
          }
          const legacyOptions = {
              locale: _locale.value,
              fallbackLocale: _fallbackLocale.value,
              messages: _messages.value,
              dateTimeFormats: _datetimeFormats.value,
              numberFormats: _numberFormats.value,
              modifiers: _modifiers,
              missing: _missing,
              fallbackRoot: _fallbackRoot,
              postTranslation: _postTranslation,
              pluralizationRules: _pluralRules,
              escapeParameterHtml: _escapeParameter,
              sync: _inheritLocale,
              silentFallbackWarn: isBoolean(_fallbackWarn)
                  ? !_fallbackWarn
                  : _fallbackWarn,
              silentTranslationWarn: isBoolean(_missingWarn)
                  ? !_missingWarn
                  : _missingWarn,
              formatFallbackMessages: isBoolean(_fallbackFormat)
                  ? !_fallbackFormat
                  : _fallbackFormat,
              warnHtmlInMessage: isBoolean(_warnHtmlMessage)
                  ? _warnHtmlMessage
                      ? 'warn'
                      : 'off'
                  : 'off',
              __VUE_I18N_BRIDGE__
          };
          __legacy = new VueI18nLegacy(legacyOptions);
      }
      // runtime context
      // eslint-disable-next-line prefer-const
      let _context;
      const getCoreContext = () => {
          _isGlobal && setFallbackContext(null);
          const ctxOptions = {
              version: VERSION,
              locale: _locale.value,
              fallbackLocale: _fallbackLocale.value,
              messages: _messages.value,
              modifiers: _modifiers,
              pluralRules: _pluralRules,
              missing: _runtimeMissing === null ? undefined : _runtimeMissing,
              missingWarn: _missingWarn,
              fallbackWarn: _fallbackWarn,
              fallbackFormat: _fallbackFormat,
              unresolving: true,
              postTranslation: _postTranslation === null ? undefined : _postTranslation,
              warnHtmlMessage: _warnHtmlMessage,
              escapeParameter: _escapeParameter,
              messageResolver: options.messageResolver,
              messageCompiler: options.messageCompiler,
              __meta: { framework: 'vue' }
          };
          {
              ctxOptions.datetimeFormats = _datetimeFormats.value;
              ctxOptions.numberFormats = _numberFormats.value;
              ctxOptions.__datetimeFormatters = isPlainObject(_context)
                  ? _context.__datetimeFormatters
                  : undefined;
              ctxOptions.__numberFormatters = isPlainObject(_context)
                  ? _context.__numberFormatters
                  : undefined;
          }
          const ctx = createCoreContext(ctxOptions);
          _isGlobal && setFallbackContext(ctx);
          return ctx;
      };
      _context = getCoreContext();
      updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      // track reactivity
      function trackReactivityValues() {
          return [
                  _locale.value,
                  _fallbackLocale.value,
                  _messages.value,
                  _datetimeFormats.value,
                  _numberFormats.value
              ]
              ;
      }
      // locale
      const locale = vueDemi.computed({
          get: () => _locale.value,
          set: val => {
              _locale.value = val;
              {
                  if (__legacy && !_isGlobal) {
                      __legacy.locale = val;
                  }
              }
              _context.locale = _locale.value;
          }
      });
      // fallbackLocale
      const fallbackLocale = vueDemi.computed({
          get: () => _fallbackLocale.value,
          set: val => {
              _fallbackLocale.value = val;
              {
                  if (__legacy && !_isGlobal) {
                      __legacy.fallbackLocale = val;
                  }
              }
              _context.fallbackLocale = _fallbackLocale.value;
              updateFallbackLocale(_context, _locale.value, val);
          }
      });
      // messages
      const messages = vueDemi.computed(() => _messages.value);
      // datetimeFormats
      const datetimeFormats = /* #__PURE__*/ vueDemi.computed(() => _datetimeFormats.value);
      // numberFormats
      const numberFormats = /* #__PURE__*/ vueDemi.computed(() => _numberFormats.value);
      // getPostTranslationHandler
      function getPostTranslationHandler() {
          return isFunction(_postTranslation) ? _postTranslation : null;
      }
      // setPostTranslationHandler
      function setPostTranslationHandler(handler) {
          _postTranslation = handler;
          _context.postTranslation = handler;
      }
      // getMissingHandler
      function getMissingHandler() {
          return _missing;
      }
      // setMissingHandler
      function setMissingHandler(handler) {
          if (handler !== null) {
              _runtimeMissing = defineCoreMissingHandler(handler);
          }
          _missing = handler;
          _context.missing = _runtimeMissing;
      }
      function isResolvedTranslateMessage(type, arg // eslint-disable-line @typescript-eslint/no-explicit-any
      ) {
          return type !== 'translate' || !arg.resolvedMessage;
      }
      const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
          trackReactivityValues(); // track reactive dependency
          // NOTE: experimental !!
          let ret;
          try {
              if (true || false) {
                  setAdditionalMeta(getMetaInfo());
              }
              if (!_isGlobal) {
                  _context.fallbackContext = __root
                      ? getFallbackContext()
                      : undefined;
              }
              ret = fn(_context);
          }
          finally {
              if (!_isGlobal) {
                  _context.fallbackContext = undefined;
              }
          }
          if ((warnType !== 'translate exists' && // for not `te` (e.g `t`)
              isNumber(ret) &&
              ret === NOT_REOSLVED) ||
              (warnType === 'translate exists' && !ret) // for `te`
          ) {
              const [key, arg2] = argumentParser();
              if (__root &&
                  isString(key) &&
                  isResolvedTranslateMessage(warnType, arg2)) {
                  if (_fallbackRoot &&
                      (isTranslateFallbackWarn(_fallbackWarn, key) ||
                          isTranslateMissingWarn(_missingWarn, key))) {
                      warn(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
                          key,
                          type: warnType
                      }));
                  }
              }
              return __root && _fallbackRoot
                  ? fallbackSuccess(__root)
                  : fallbackFail(key);
          }
          else if (successCondition(ret)) {
              return ret;
          }
          else {
              /* istanbul ignore next */
              throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
          }
      };
      // t
      function t(...args) {
          return wrapWithDeps(context => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), 'translate', root => Reflect.apply(root.t, root, [...args]), key => key, val => isString(val));
      }
      // rt
      function rt(...args) {
          const [arg1, arg2, arg3] = args;
          if (arg3 && !isObject(arg3)) {
              throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          return t(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
      }
      // d
      function d(...args) {
          return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', root => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, val => isString(val));
      }
      // n
      function n(...args) {
          return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', root => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, val => isString(val));
      }
      // for custom processor
      function normalize(values) {
          return values.map(val => isString(val) || isNumber(val) || isBoolean(val)
              ? createTextNode(String(val))
              : val);
      }
      const interpolate = (val) => val;
      const processor = {
          normalize,
          interpolate,
          type: 'vnode'
      };
      // translateVNode, using for `i18n-t` component
      function translateVNode(...args) {
          return wrapWithDeps(context => {
              let ret;
              const _context = context;
              try {
                  _context.processor = processor;
                  ret = Reflect.apply(translate, null, [_context, ...args]);
              }
              finally {
                  _context.processor = null;
              }
              return ret;
          }, () => parseTranslateArgs(...args), 'translate', 
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          root => root[TranslateVNodeSymbol](...args), key => [createTextNode(key)], val => isArray(val));
      }
      // numberParts, using for `i18n-n` component
      function numberParts(...args) {
          return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', 
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          root => root[NumberPartsSymbol](...args), NOOP_RETURN_ARRAY, val => isString(val) || isArray(val));
      }
      // datetimeParts, using for `i18n-d` component
      function datetimeParts(...args) {
          return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', 
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          root => root[DatetimePartsSymbol](...args), NOOP_RETURN_ARRAY, val => isString(val) || isArray(val));
      }
      function setPluralRules(rules) {
          _pluralRules = rules;
          _context.pluralRules = _pluralRules;
      }
      // te
      function te(key, locale) {
          return wrapWithDeps(() => {
              if (!key) {
                  return false;
              }
              const targetLocale = isString(locale) ? locale : _locale.value;
              const message = getLocaleMessage(targetLocale);
              const resolved = _context.messageResolver(message, key);
              return !translateExistCompatible
                  ? isMessageAST(resolved) ||
                      isMessageFunction(resolved) ||
                      isString(resolved)
                  : resolved != null;
          }, () => [key], 'translate exists', root => {
              return Reflect.apply(root.te, root, [key, locale]);
          }, NOOP_RETURN_FALSE, val => isBoolean(val));
      }
      function resolveMessages(key) {
          let messages = null;
          const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
          for (let i = 0; i < locales.length; i++) {
              const targetLocaleMessages = _messages.value[locales[i]] || {};
              const messageValue = _context.messageResolver(targetLocaleMessages, key);
              if (messageValue != null) {
                  messages = messageValue;
                  break;
              }
          }
          return messages;
      }
      // tm
      function tm(key) {
          const messages = resolveMessages(key);
          // prettier-ignore
          return messages != null
              ? messages
              : __root
                  ? __root.tm(key) || {}
                  : {};
      }
      // getLocaleMessage
      function getLocaleMessage(locale) {
          return (_messages.value[locale] || {});
      }
      // setLocaleMessage
      function setLocaleMessage(locale, message) {
          if (flatJson) {
              const _message = { [locale]: message };
              for (const key in _message) {
                  if (hasOwn(_message, key)) {
                      handleFlatJson(_message[key]);
                  }
              }
              message = _message[locale];
          }
          _messages.value[locale] = message;
          {
              __legacy && __legacy.setLocaleMessage(locale, message);
          }
          _context.messages = _messages.value;
      }
      // mergeLocaleMessage
      function mergeLocaleMessage(locale, message) {
          _messages.value[locale] = _messages.value[locale] || {};
          {
              __legacy && __legacy.mergeLocaleMessage(locale, message);
          }
          const _message = { [locale]: message };
          if (flatJson) {
              for (const key in _message) {
                  if (hasOwn(_message, key)) {
                      handleFlatJson(_message[key]);
                  }
              }
          }
          message = _message[locale];
          deepCopy(message, _messages.value[locale]);
          _context.messages = _messages.value;
      }
      // getDateTimeFormat
      function getDateTimeFormat(locale) {
          return _datetimeFormats.value[locale] || {};
      }
      // setDateTimeFormat
      function setDateTimeFormat(locale, format) {
          _datetimeFormats.value[locale] = format;
          {
              __legacy && __legacy.setDateTimeFormat(locale, format);
          }
          _context.datetimeFormats = _datetimeFormats.value;
          clearDateTimeFormat(_context, locale, format);
      }
      // mergeDateTimeFormat
      function mergeDateTimeFormat(locale, format) {
          _datetimeFormats.value[locale] = assign(_datetimeFormats.value[locale] || {}, format);
          {
              __legacy && __legacy.mergeDateTimeFormat(locale, format);
          }
          _context.datetimeFormats = _datetimeFormats.value;
          clearDateTimeFormat(_context, locale, format);
      }
      // getNumberFormat
      function getNumberFormat(locale) {
          return _numberFormats.value[locale] || {};
      }
      // setNumberFormat
      function setNumberFormat(locale, format) {
          _numberFormats.value[locale] = format;
          {
              __legacy && __legacy.setNumberFormat(locale, format);
          }
          _context.numberFormats = _numberFormats.value;
          clearNumberFormat(_context, locale, format);
      }
      // mergeNumberFormat
      function mergeNumberFormat(locale, format) {
          _numberFormats.value[locale] = assign(_numberFormats.value[locale] || {}, format);
          {
              __legacy && __legacy.mergeNumberFormat(locale, format);
          }
          _context.numberFormats = _numberFormats.value;
          clearNumberFormat(_context, locale, format);
      }
      // for debug
      composerID++;
      // watch root locale & fallbackLocale
      if (__root && inBrowser) {
          vueDemi.watch(__root.locale, (val) => {
              if (_inheritLocale) {
                  _locale.value = val;
                  {
                      if (__legacy && !_isGlobal) {
                          __legacy.locale = val;
                      }
                  }
                  _context.locale = val;
                  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
              }
          });
          vueDemi.watch(__root.fallbackLocale, (val) => {
              if (_inheritLocale) {
                  _fallbackLocale.value = val;
                  {
                      if (__legacy && !_isGlobal) {
                          __legacy.fallbackLocale = val;
                      }
                  }
                  _context.fallbackLocale = val;
                  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
              }
          });
      }
      // define basic composition API!
      const composer = {
          id: composerID,
          locale,
          fallbackLocale,
          get inheritLocale() {
              return _inheritLocale;
          },
          set inheritLocale(val) {
              _inheritLocale = val;
              {
                  if (__legacy) {
                      __legacy._sync = val;
                  }
              }
              if (val && __root) {
                  _locale.value = __root.locale.value;
                  _fallbackLocale.value = __root.fallbackLocale.value;
                  {
                      if (__legacy) {
                          __legacy.locale = __root.locale.value;
                          __legacy.fallbackLocale = __root.fallbackLocale.value;
                      }
                  }
                  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
              }
          },
          get availableLocales() {
              return Object.keys(_messages.value).sort();
          },
          messages,
          get modifiers() {
              return _modifiers;
          },
          get pluralRules() {
              return _pluralRules || {};
          },
          get isGlobal() {
              return _isGlobal;
          },
          get missingWarn() {
              return _missingWarn;
          },
          set missingWarn(val) {
              _missingWarn = val;
              _context.missingWarn = _missingWarn;
          },
          get fallbackWarn() {
              return _fallbackWarn;
          },
          set fallbackWarn(val) {
              _fallbackWarn = val;
              _context.fallbackWarn = _fallbackWarn;
          },
          get fallbackRoot() {
              return _fallbackRoot;
          },
          set fallbackRoot(val) {
              _fallbackRoot = val;
          },
          get fallbackFormat() {
              return _fallbackFormat;
          },
          set fallbackFormat(val) {
              _fallbackFormat = val;
              _context.fallbackFormat = _fallbackFormat;
          },
          get warnHtmlMessage() {
              return _warnHtmlMessage;
          },
          set warnHtmlMessage(val) {
              _warnHtmlMessage = val;
              _context.warnHtmlMessage = val;
          },
          get escapeParameter() {
              return _escapeParameter;
          },
          set escapeParameter(val) {
              _escapeParameter = val;
              _context.escapeParameter = val;
          },
          t,
          getLocaleMessage,
          setLocaleMessage,
          mergeLocaleMessage,
          getPostTranslationHandler,
          setPostTranslationHandler,
          getMissingHandler,
          setMissingHandler,
          [SetPluralRulesSymbol]: setPluralRules
      };
      {
          composer.datetimeFormats = datetimeFormats;
          composer.numberFormats = numberFormats;
          composer.rt = rt;
          composer.te = te;
          composer.tm = tm;
          composer.d = d;
          composer.n = n;
          composer.getDateTimeFormat = getDateTimeFormat;
          composer.setDateTimeFormat = setDateTimeFormat;
          composer.mergeDateTimeFormat = mergeDateTimeFormat;
          composer.getNumberFormat = getNumberFormat;
          composer.setNumberFormat = setNumberFormat;
          composer.mergeNumberFormat = mergeNumberFormat;
          composer[InejctWithOptionSymbol] = __injectWithOption;
          composer[TranslateVNodeSymbol] = translateVNode;
          composer[DatetimePartsSymbol] = datetimeParts;
          composer[NumberPartsSymbol] = numberParts;
      }
      {
          composer[LegacyInstanceSymbol] = __legacy;
      }
      return composer;
  }
  /* eslint-enable @typescript-eslint/no-explicit-any */

  const baseFormatProps = {
      tag: {
          type: [String, Object]
      },
      locale: {
          type: String
      },
      scope: {
          type: String,
          // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
          validator: (val /* ComponentI18nScope */) => val === 'parent' || val === 'global',
          default: 'parent' /* ComponentI18nScope */
      },
      i18n: {
          type: Object
      }
  };

  function getInterpolateArg(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  { slots }, // SetupContext,
  keys) {
      if (keys.length === 1 && keys[0] === 'default') {
          // default slot with list
          const ret = slots.default ? slots.default() : [];
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return ret.reduce((slot, current) => {
              return [
                  ...slot,
                  // prettier-ignore
                  ...(current.children ? current.children : [current])
              ];
          }, []);
      }
      else {
          // named slots
          return keys.reduce((arg, key) => {
              const slot = slots[key];
              if (slot) {
                  arg[key] = slot();
              }
              return arg;
          }, {});
      }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function getFragmentableTag(tag) {
      return tag;
  }

  const TranslationImpl = /*#__PURE__*/ vueDemi.defineComponent({
      /* eslint-disable */
      name: 'i18n-t',
      props: assign({
          keypath: {
              type: String,
              required: true
          },
          plural: {
              type: [Number, String],
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              validator: (val) => isNumber(val) || !isNaN(val)
          }
      }, baseFormatProps),
      /* eslint-enable */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setup(props, context) {
          const { slots, attrs } = context;
          // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
          const i18n = props.i18n ||
              useI18n({
                  useScope: props.scope,
                  __useComponent: true
              });
          return () => {
              const keys = Object.keys(slots).filter(key => key !== '_');
              const options = {};
              if (props.locale) {
                  options.locale = props.locale;
              }
              if (props.plural !== undefined) {
                  options.plural = isString(props.plural) ? +props.plural : props.plural;
              }
              const arg = getInterpolateArg(context, keys);
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
              const assignedAttrs = assign({}, attrs);
              const tag = isString(props.tag) || isObject(props.tag)
                  ? props.tag
                  : getFragmentableTag('span');
              return vueDemi.h(tag, assignedAttrs, children);
          };
      }
  });
  /**
   * export the public type for h/tsx inference
   * also to avoid inline import() in generated d.ts files
   */
  /**
   * Translation Component
   *
   * @remarks
   * See the following items for property about details
   *
   * @VueI18nSee [TranslationProps](component#translationprops)
   * @VueI18nSee [BaseFormatProps](component#baseformatprops)
   * @VueI18nSee [Component Interpolation](../guide/advanced/component)
   *
   * @example
   * ```html
   * <div id="app">
   *   <!-- ... -->
   *   <i18n keypath="term" tag="label" for="tos">
   *     <a :href="url" target="_blank">{{ $t('tos') }}</a>
   *   </i18n>
   *   <!-- ... -->
   * </div>
   * ```
   * ```js
   * import { createApp } from 'vue'
   * import { createI18n } from 'vue-i18n'
   *
   * const messages = {
   *   en: {
   *     tos: 'Term of Service',
   *     term: 'I accept xxx {0}.'
   *   },
   *   ja: {
   *     tos: '利用規約',
   *     term: '私は xxx の{0}に同意します。'
   *   }
   * }
   *
   * const i18n = createI18n({
   *   locale: 'en',
   *   messages
   * })
   *
   * const app = createApp({
   *   data: {
   *     url: '/term'
   *   }
   * }).use(i18n).mount('#app')
   * ```
   *
   * @VueI18nComponent
   */
  const Translation = TranslationImpl;
  const I18nT = Translation;

  function isVNode(target) {
      return isArray(target) && !isString(target[0]);
  }
  function renderFormatter(props, context, slotKeys, partFormatter) {
      const { slots, attrs } = context;
      return () => {
          const options = { part: true };
          let overrides = {};
          if (props.locale) {
              options.locale = props.locale;
          }
          if (isString(props.format)) {
              options.key = props.format;
          }
          else if (isObject(props.format)) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              if (isString(props.format.key)) {
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  options.key = props.format.key;
              }
              // Filter out number format options only
              overrides = Object.keys(props.format).reduce((options, prop) => {
                  return slotKeys.includes(prop)
                      ? assign({}, options, { [prop]: props.format[prop] }) // eslint-disable-line @typescript-eslint/no-explicit-any
                      : options;
              }, {});
          }
          const parts = partFormatter(...[props.value, options, overrides]);
          let children = [options.key];
          if (isArray(parts)) {
              children = parts.map((part, index) => {
                  const slot = slots[part.type];
                  const node = slot
                      ? slot({ [part.type]: part.value, index, parts })
                      : [part.value];
                  if (isVNode(node)) {
                      node[0].key = `${part.type}-${index}`;
                  }
                  return node;
              });
          }
          else if (isString(parts)) {
              children = [parts];
          }
          const assignedAttrs = assign({}, attrs);
          const tag = isString(props.tag) || isObject(props.tag)
              ? props.tag
              : getFragmentableTag('span');
          return vueDemi.h(tag, assignedAttrs, children);
      };
  }

  const NumberFormatImpl = /*#__PURE__*/ vueDemi.defineComponent({
      /* eslint-disable */
      name: 'i18n-n',
      props: assign({
          value: {
              type: Number,
              required: true
          },
          format: {
              type: [String, Object]
          }
      }, baseFormatProps),
      /* eslint-enable */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setup(props, context) {
          const i18n = props.i18n ||
              useI18n({
                  useScope: props.scope,
                  __useComponent: true
              });
          return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => 
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          i18n[NumberPartsSymbol](...args));
      }
  });
  /**
   * export the public type for h/tsx inference
   * also to avoid inline import() in generated d.ts files
   */
  /**
   * Number Format Component
   *
   * @remarks
   * See the following items for property about details
   *
   * @VueI18nSee [FormattableProps](component#formattableprops)
   * @VueI18nSee [BaseFormatProps](component#baseformatprops)
   * @VueI18nSee [Custom Formatting](../guide/essentials/number#custom-formatting)
   *
   * @VueI18nDanger
   * Not supported IE, due to no support `Intl.NumberFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatToParts)
   *
   * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-numberformat)
   *
   * @VueI18nComponent
   */
  const NumberFormat = NumberFormatImpl;
  const I18nN = NumberFormat;

  const DatetimeFormatImpl = /* #__PURE__*/ vueDemi.defineComponent({
      /* eslint-disable */
      name: 'i18n-d',
      props: assign({
          value: {
              type: [Number, Date],
              required: true
          },
          format: {
              type: [String, Object]
          }
      }, baseFormatProps),
      /* eslint-enable */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setup(props, context) {
          const i18n = props.i18n ||
              useI18n({
                  useScope: props.scope,
                  __useComponent: true
              });
          return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => 
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          i18n[DatetimePartsSymbol](...args));
      }
  });
  /**
   * Datetime Format Component
   *
   * @remarks
   * See the following items for property about details
   *
   * @VueI18nSee [FormattableProps](component#formattableprops)
   * @VueI18nSee [BaseFormatProps](component#baseformatprops)
   * @VueI18nSee [Custom Formatting](../guide/essentials/datetime#custom-formatting)
   *
   * @VueI18nDanger
   * Not supported IE, due to no support `Intl.DateTimeFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts)
   *
   * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-datetimeformat)
   *
   * @VueI18nComponent
   */
  const DatetimeFormat = DatetimeFormatImpl;
  const I18nD = DatetimeFormat;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function apply(Vue, ...options) {
      const pluginOptions = isPlainObject(options[0])
          ? options[0]
          : {};
      const globalInstall = isBoolean(pluginOptions.globalInstall)
          ? pluginOptions.globalInstall
          : true;
      if (globalInstall) {
          // install components
          Vue.component(Translation.name, Translation);
          Vue.component(NumberFormat.name, NumberFormat);
          Vue.component(DatetimeFormat.name, DatetimeFormat);
      }
  }

  /**
   * Port from vue-i18n@v8.x
   * This mixin is used when we use vue-i18n-bridge
   */
  function defineMixin(i18n, VueI18n // eslint-disable-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  ) {
      return {
          beforeCreate() {
              const options = this.$options; // eslint-disable-line @typescript-eslint/no-explicit-any
              if (options.__VUE18N__INSTANCE__) {
                  return;
              }
              options.i18n = options.i18n || (options.__i18nBridge ? {} : null);
              this._i18nBridgeRoot = i18n;
              if (i18n.mode === 'composition') {
                  this._i18n = i18n;
                  return;
              }
              if (options.i18n) {
                  if (options.i18n instanceof VueI18n) {
                      // init locale messages via custom blocks
                      if (options.__i18nBridge) {
                          try {
                              const localeMessages = options.i18n && options.i18n.messages
                                  ? options.i18n.messages
                                  : {};
                              options.__i18nBridge.forEach(resource => deepCopy(JSON.parse(resource), localeMessages));
                              Object.keys(localeMessages).forEach((locale) => {
                                  options.i18n.mergeLocaleMessage(locale, localeMessages[locale]);
                              });
                          }
                          catch (e) {
                              {
                                  console.error(`Cannot parse locale messages via custom blocks.`, e);
                              }
                          }
                      }
                      this._i18n = options.i18n;
                      this._i18nWatcher = this._i18n.watchI18nData();
                  }
                  else if (isPlainObject(options.i18n)) {
                      const rootI18n = this.$root &&
                          this.$root.$i18n &&
                          this.$root.$i18n instanceof VueI18n
                          ? this.$root.$i18n
                          : null;
                      // component local i18n
                      if (rootI18n) {
                          options.i18n.root = this.$root;
                          options.i18n.formatter = rootI18n.formatter;
                          options.i18n.fallbackLocale = rootI18n.fallbackLocale;
                          options.i18n.formatFallbackMessages =
                              rootI18n.formatFallbackMessages;
                          options.i18n.silentTranslationWarn = rootI18n.silentTranslationWarn;
                          options.i18n.silentFallbackWarn = rootI18n.silentFallbackWarn;
                          options.i18n.pluralizationRules = rootI18n.pluralizationRules;
                          options.i18n.preserveDirectiveContent =
                              rootI18n.preserveDirectiveContent;
                      }
                      // init locale messages via custom blocks
                      if (options.__i18nBridge) {
                          try {
                              const localeMessages = options.i18n && options.i18n.messages
                                  ? options.i18n.messages
                                  : {};
                              options.__i18nBridge.forEach(resource => deepCopy(JSON.parse(resource), localeMessages));
                              options.i18n.messages = localeMessages;
                          }
                          catch (e) {
                              {
                                  warn(`Cannot parse locale messages via custom blocks.`, e);
                              }
                          }
                      }
                      const { sharedMessages } = options.i18n;
                      if (sharedMessages && isPlainObject(sharedMessages)) {
                          deepCopy(sharedMessages, options.i18n.messages);
                      }
                      this._i18n = new VueI18n(options.i18n);
                      this._i18nWatcher = this._i18n.watchI18nData();
                      if (options.i18n.sync === undefined || !!options.i18n.sync) {
                          this._localeWatcher = this.$i18n.watchLocale();
                      }
                      if (rootI18n) {
                          rootI18n.onComponentInstanceCreated(this._i18n);
                      }
                  }
                  else {
                      {
                          warn(`Cannot be interpreted 'i18n' option.`);
                      }
                  }
              }
              else if (this.$root &&
                  this.$root.$i18n &&
                  this.$root.$i18n instanceof VueI18n) {
                  // root i18n
                  this._i18n = this.$root.$i18n;
              }
              else if (options.parent &&
                  options.parent.$i18n &&
                  options.parent.$i18n instanceof VueI18n) {
                  // parent i18n
                  this._i18n = options.parent.$i18n;
              }
          },
          beforeMount() {
              const options = this.$options; // eslint-disable-line @typescript-eslint/no-explicit-any
              if (options.__VUE18N__INSTANCE__) {
                  return;
              }
              if (i18n.mode === 'composition') {
                  return;
              }
              options.i18n = options.i18n || (options.__i18nBridge ? {} : null);
              if (options.i18n) {
                  if (options.i18n instanceof VueI18n) {
                      // init locale messages via custom blocks
                      this._i18n.subscribeDataChanging(this);
                      this._subscribing = true;
                  }
                  else if (isPlainObject(options.i18n)) {
                      this._i18n.subscribeDataChanging(this);
                      this._subscribing = true;
                  }
                  else {
                      {
                          warn(`Cannot be interpreted 'i18n' option.`);
                      }
                  }
              }
              else if (this.$root &&
                  this.$root.$i18n &&
                  this.$root.$i18n instanceof VueI18n) {
                  this._i18n.subscribeDataChanging(this);
                  this._subscribing = true;
              }
              else if (options.parent &&
                  options.parent.$i18n &&
                  options.parent.$i18n instanceof VueI18n) {
                  this._i18n.subscribeDataChanging(this);
                  this._subscribing = true;
              }
          },
          beforeDestroy() {
              const options = this.$options; // eslint-disable-line @typescript-eslint/no-explicit-any
              if (options.__VUE18N__INSTANCE__) {
                  return;
              }
              if (this._i18nBridgeRoot) {
                  delete this._i18nBridgeRoot;
                  return;
              }
              if (i18n.mode === 'composition') {
                  delete this._i18n;
                  return;
              }
              if (!this._i18n) {
                  return;
              }
              const self = this; // eslint-disable-line @typescript-eslint/no-explicit-any
              this.$nextTick(() => {
                  if (self._subscribing) {
                      self._i18n.unsubscribeDataChanging(self);
                      delete self._subscribing;
                  }
                  if (self._i18nWatcher) {
                      self._i18nWatcher();
                      self._i18n.destroyVM();
                      delete self._i18nWatcher;
                  }
                  if (self._localeWatcher) {
                      self._localeWatcher();
                      delete self._localeWatcher;
                  }
              });
          }
      };
  }

  // for bridge
  let _legacyVueI18n =  null; // eslint-disable-line @typescript-eslint/no-explicit-any
  /**
   * Injection key for {@link useI18n}
   *
   * @remarks
   * The global injection key for I18n instances with `useI18n`. this injection key is used in Web Components.
   * Specify the i18n instance created by {@link createI18n} together with `provide` function.
   *
   * @VueI18nGeneral
   */
  const I18nInjectionKey = 
  /* #__PURE__*/ makeSymbol('global-vue-i18n');
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  function createI18n(options = {}, VueI18nLegacy) {
      {
          _legacyVueI18n = VueI18nLegacy;
      }
      // prettier-ignore
      const __legacyMode = isBoolean(options.legacy)
              ? options.legacy
              : true;
      // prettier-ignore
      const __globalInjection = isBoolean(options.globalInjection)
          ? options.globalInjection
          : true;
      // prettier-ignore
      const __allowComposition = __legacyMode
              ? !!options.allowComposition
              : true;
      const __instances = new Map();
      const [globalScope, __global] = createGlobal(options, __legacyMode, VueI18nLegacy);
      {
          if (__legacyMode && __allowComposition && !false) {
              warn(getWarnMessage(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
          }
      }
      function __getInstance(component) {
          return __instances.get(component) || null;
      }
      function __setInstance(component, instance) {
          __instances.set(component, instance);
      }
      function __deleteInstance(component) {
          __instances.delete(component);
      }
      {
          // extend legacy VueI18n instance
          const i18n = __global[LegacyInstanceSymbol]; // eslint-disable-line @typescript-eslint/no-explicit-any
          let _localeWatcher = null;
          Object.defineProperty(i18n, 'global', {
              get() {
                  return __global;
              }
          });
          Object.defineProperty(i18n, 'mode', {
              get() {
                  return __legacyMode ? 'legacy' : 'composition';
              }
          });
          Object.defineProperty(i18n, 'allowComposition', {
              get() {
                  return __allowComposition;
              }
          });
          Object.defineProperty(i18n, '__instances', {
              get() {
                  return __instances;
              }
          });
          Object.defineProperty(i18n, 'install', {
              writable: true,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value: (Vue, ...options) => {
                  const version = (Vue && Vue.version && Number(Vue.version.split('.')[0])) || -1;
                  if (version !== 2) {
                      throw createI18nError(I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY);
                  }
                  apply(Vue, ...options);
                  if (!__legacyMode && __globalInjection) {
                      _localeWatcher = injectGlobalFieldsForBridge(Vue, i18n, __global);
                  }
                  Vue.mixin(defineMixin(i18n, _legacyVueI18n));
              }
          });
          Object.defineProperty(i18n, 'dispose', {
              value: () => {
                  _localeWatcher && _localeWatcher();
                  globalScope.stop();
              }
          });
          const methodMap = {
              __getInstance,
              __setInstance,
              __deleteInstance
          };
          Object.keys(methodMap).forEach(key => Object.defineProperty(i18n, key, { value: methodMap[key] }) // eslint-disable-line @typescript-eslint/no-explicit-any
          );
          return i18n;
      }
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function useI18n(options = {}) {
      const instance = vueDemi.getCurrentInstance();
      if (instance == null) {
          throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
      }
      {
          if (_legacyVueI18n == null) {
              throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
          }
      }
      const i18n = getI18nInstance(instance);
      const gl = getGlobalComposer(i18n);
      const componentOptions = getComponentOptions(instance);
      const scope = getScope(options, componentOptions);
      {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          if (i18n.mode === 'legacy' && !options.__useComponent) {
              if (!i18n.allowComposition) {
                  throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
              }
              return useI18nForLegacy(instance, scope, gl, options);
          }
      }
      if (scope === 'global') {
          adjustI18nResources(gl, options, componentOptions);
          return gl;
      }
      if (scope === 'parent') {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          let composer = getComposer(i18n, instance, options.__useComponent);
          if (composer == null) {
              {
                  warn(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
              }
              composer = gl;
          }
          return composer;
      }
      const i18nInternal = i18n;
      let composer = i18nInternal.__getInstance(instance);
      if (composer == null) {
          const composerOptions = assign({}, options);
          if ('__i18n' in componentOptions) {
              composerOptions.__i18n = componentOptions.__i18n;
          }
          if (gl) {
              composerOptions.__root = gl;
          }
          composer = createComposer(composerOptions, _legacyVueI18n);
          if (i18nInternal.__composerExtend) {
              composer[DisposeSymbol] =
                  i18nInternal.__composerExtend(composer);
          }
          setupLifeCycle(i18nInternal, instance, composer);
          i18nInternal.__setInstance(instance, composer);
      }
      return composer;
  }
  /**
   * Cast to VueI18n legacy compatible type
   *
   * @remarks
   * This API is provided only with [vue-i18n-bridge](https://vue-i18n.intlify.dev/guide/migration/ways.html#what-is-vue-i18n-bridge).
   *
   * The purpose of this function is to convert an {@link I18n} instance created with {@link createI18n | createI18n(legacy: true)} into a `vue-i18n@v8.x` compatible instance of `new VueI18n` in a TypeScript environment.
   *
   * @param i18n - An instance of {@link I18n}
   * @returns A i18n instance which is casted to {@link VueI18n} type
   *
   * @VueI18nTip
   * :new: provided by **vue-i18n-bridge only**
   *
   * @VueI18nGeneral
   */
  /* #__NO_SIDE_EFFECTS__ */
  const castToVueI18n = (i18n
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ) => {
      if (!(__VUE_I18N_BRIDGE__ in i18n)) {
          throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
      }
      return i18n;
  };
  function createGlobal(options, legacyMode, VueI18nLegacy // eslint-disable-line @typescript-eslint/no-explicit-any
  ) {
      const scope = vueDemi.effectScope();
      {
          if (!isLegacyVueI18n(VueI18nLegacy)) {
              throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
          }
          const obj = scope.run(() => createComposer(options, VueI18nLegacy));
          if (obj == null) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          return [scope, obj];
      }
  }
  function getI18nInstance(instance) {
      {
          const vm = instance.proxy;
          /* istanbul ignore if */
          if (vm == null) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          const i18n = vm._i18nBridgeRoot; // eslint-disable-line @typescript-eslint/no-explicit-any
          /* istanbul ignore if */
          if (!i18n) {
              throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
          }
          return i18n;
      }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function getScope(options, componentOptions) {
      // prettier-ignore
      return isEmptyObject(options)
          ? ('__i18n' in componentOptions)
              ? 'local'
              : 'global'
          : !options.useScope
              ? 'local'
              : options.useScope;
  }
  function getGlobalComposer(i18n) {
      // prettier-ignore
      return i18n.global;
  }
  function getComposer(i18n, target, useComponent = false) {
      let composer = null;
      const root = target.root;
      let current = getParentComponentInstance(target, useComponent);
      while (current != null) {
          const i18nInternal = i18n;
          if (i18n.mode === 'composition') {
              composer = i18nInternal.__getInstance(current);
          }
          else {
              {
                  const vueI18n = i18nInternal.__getInstance(current);
                  if (vueI18n != null) {
                      composer = vueI18n
                          .__composer;
                      if (useComponent &&
                          composer &&
                          !composer[InejctWithOptionSymbol] // eslint-disable-line @typescript-eslint/no-explicit-any
                      ) {
                          composer = null;
                      }
                  }
              }
          }
          if (composer != null) {
              break;
          }
          if (root === current) {
              break;
          }
          current = current.parent;
      }
      return composer;
  }
  function getParentComponentInstance(target, useComponent = false) {
      if (target == null) {
          return null;
      }
      {
          return target.parent;
      }
  }
  function setupLifeCycle(i18n, target, composer) {
      {
          // assign legacy VueI18n instance to Vue2 instance
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const vm = target.proxy;
          if (vm == null) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const _i18n = composer[LegacyInstanceSymbol];
          if (_i18n === i18n) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          vm._i18n = _i18n;
          vm._i18n_bridge = true;
          // browser only
          if (inBrowser) {
              vm._i18nWatcher = vm._i18n.watchI18nData();
              if (vm._i18n._sync) {
                  vm._localeWatcher = vm._i18n.watchLocale();
              }
          }
          let subscribing = false;
          vueDemi.onBeforeMount(() => {
              vm._i18n.subscribeDataChanging(vm);
              subscribing = true;
          });
          vueDemi.onUnmounted(() => {
              if (subscribing) {
                  vm._i18n.unsubscribeDataChanging(vm);
                  subscribing = false;
              }
              if (vm._i18nWatcher) {
                  vm._i18nWatcher();
                  vm._i18n.destroyVM();
                  delete vm._i18nWatcher;
              }
              if (vm._localeWatcher) {
                  vm._localeWatcher();
                  delete vm._localeWatcher;
              }
              delete vm._i18n_bridge;
              delete vm._i18n;
          });
      }
  }
  function useI18nForLegacy(instance, scope, root, options = {} // eslint-disable-line @typescript-eslint/no-explicit-any
  ) {
      const isLocalScope = scope === 'local';
      const _composer = vueDemi.shallowRef(null);
      if (isLocalScope &&
          instance.proxy &&
          !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
          throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
      }
      const _inheritLocale = isBoolean(options.inheritLocale)
          ? options.inheritLocale
          : !isString(options.locale);
      const _locale = vueDemi.ref(
      // prettier-ignore
      !isLocalScope || _inheritLocale
          ? root.locale.value
          : isString(options.locale)
              ? options.locale
              : DEFAULT_LOCALE);
      const _fallbackLocale = vueDemi.ref(
      // prettier-ignore
      !isLocalScope || _inheritLocale
          ? root.fallbackLocale.value
          : isString(options.fallbackLocale) ||
              isArray(options.fallbackLocale) ||
              isPlainObject(options.fallbackLocale) ||
              options.fallbackLocale === false
              ? options.fallbackLocale
              : _locale.value);
      const _messages = vueDemi.ref(getLocaleMessages(_locale.value, options));
      // prettier-ignore
      const _datetimeFormats = vueDemi.ref(isPlainObject(options.datetimeFormats)
          ? options.datetimeFormats
          : { [_locale.value]: {} });
      // prettier-ignore
      const _numberFormats = vueDemi.ref(isPlainObject(options.numberFormats)
          ? options.numberFormats
          : { [_locale.value]: {} });
      // prettier-ignore
      const _missingWarn = isLocalScope
          ? root.missingWarn
          : isBoolean(options.missingWarn) || isRegExp(options.missingWarn)
              ? options.missingWarn
              : true;
      // prettier-ignore
      const _fallbackWarn = isLocalScope
          ? root.fallbackWarn
          : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn)
              ? options.fallbackWarn
              : true;
      // prettier-ignore
      const _fallbackRoot = isLocalScope
          ? root.fallbackRoot
          : isBoolean(options.fallbackRoot)
              ? options.fallbackRoot
              : true;
      // configure fall back to root
      const _fallbackFormat = !!options.fallbackFormat;
      // runtime missing
      const _missing = isFunction(options.missing) ? options.missing : null;
      // postTranslation handler
      const _postTranslation = isFunction(options.postTranslation)
          ? options.postTranslation
          : null;
      // prettier-ignore
      const _warnHtmlMessage = isLocalScope
          ? root.warnHtmlMessage
          : isBoolean(options.warnHtmlMessage)
              ? options.warnHtmlMessage
              : true;
      const _escapeParameter = !!options.escapeParameter;
      // prettier-ignore
      const _modifiers = isLocalScope
          ? root.modifiers
          : isPlainObject(options.modifiers)
              ? options.modifiers
              : {};
      // pluralRules
      const _pluralRules = options.pluralRules || (isLocalScope && root.pluralRules);
      // track reactivity
      function trackReactivityValues() {
          return [
              _locale.value,
              _fallbackLocale.value,
              _messages.value,
              _datetimeFormats.value,
              _numberFormats.value
          ];
      }
      // locale
      const locale = vueDemi.computed({
          get: () => {
              return _composer.value ? _composer.value.locale.value : _locale.value;
          },
          set: val => {
              if (_composer.value) {
                  _composer.value.locale.value = val;
              }
              _locale.value = val;
          }
      });
      // fallbackLocale
      const fallbackLocale = vueDemi.computed({
          get: () => {
              return _composer.value
                  ? _composer.value.fallbackLocale.value
                  : _fallbackLocale.value;
          },
          set: val => {
              if (_composer.value) {
                  _composer.value.fallbackLocale.value = val;
              }
              _fallbackLocale.value = val;
          }
      });
      // messages
      const messages = vueDemi.computed(() => {
          if (_composer.value) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              return _composer.value.messages.value;
          }
          else {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              return _messages.value;
          }
      });
      const datetimeFormats = vueDemi.computed(() => _datetimeFormats.value);
      const numberFormats = vueDemi.computed(() => _numberFormats.value);
      function getPostTranslationHandler() {
          return _composer.value
              ? _composer.value.getPostTranslationHandler()
              : _postTranslation;
      }
      function setPostTranslationHandler(handler) {
          if (_composer.value) {
              _composer.value.setPostTranslationHandler(handler);
          }
      }
      function getMissingHandler() {
          return _composer.value ? _composer.value.getMissingHandler() : _missing;
      }
      function setMissingHandler(handler) {
          if (_composer.value) {
              _composer.value.setMissingHandler(handler);
          }
      }
      function warpWithDeps(fn) {
          trackReactivityValues();
          return fn();
      }
      function t(...args) {
          return _composer.value
              ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args]))
              : warpWithDeps(() => '');
      }
      function rt(...args) {
          return _composer.value
              ? Reflect.apply(_composer.value.rt, null, [...args])
              : '';
      }
      function d(...args) {
          return _composer.value
              ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args]))
              : warpWithDeps(() => '');
      }
      function n(...args) {
          return _composer.value
              ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args]))
              : warpWithDeps(() => '');
      }
      function tm(key) {
          return _composer.value ? _composer.value.tm(key) : {};
      }
      function te(key, locale) {
          return _composer.value ? _composer.value.te(key, locale) : false;
      }
      function getLocaleMessage(locale) {
          return _composer.value ? _composer.value.getLocaleMessage(locale) : {};
      }
      function setLocaleMessage(locale, message) {
          if (_composer.value) {
              _composer.value.setLocaleMessage(locale, message);
              _messages.value[locale] = message;
          }
      }
      function mergeLocaleMessage(locale, message) {
          if (_composer.value) {
              _composer.value.mergeLocaleMessage(locale, message);
          }
      }
      function getDateTimeFormat(locale) {
          return _composer.value ? _composer.value.getDateTimeFormat(locale) : {};
      }
      function setDateTimeFormat(locale, format) {
          if (_composer.value) {
              _composer.value.setDateTimeFormat(locale, format);
              _datetimeFormats.value[locale] = format;
          }
      }
      function mergeDateTimeFormat(locale, format) {
          if (_composer.value) {
              _composer.value.mergeDateTimeFormat(locale, format);
          }
      }
      function getNumberFormat(locale) {
          return _composer.value ? _composer.value.getNumberFormat(locale) : {};
      }
      function setNumberFormat(locale, format) {
          if (_composer.value) {
              _composer.value.setNumberFormat(locale, format);
              _numberFormats.value[locale] = format;
          }
      }
      function mergeNumberFormat(locale, format) {
          if (_composer.value) {
              _composer.value.mergeNumberFormat(locale, format);
          }
      }
      const wrapper = {
          get id() {
              return _composer.value ? _composer.value.id : -1;
          },
          locale,
          fallbackLocale,
          messages,
          datetimeFormats,
          numberFormats,
          get inheritLocale() {
              return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
          },
          set inheritLocale(val) {
              if (_composer.value) {
                  _composer.value.inheritLocale = val;
              }
          },
          get availableLocales() {
              return _composer.value
                  ? _composer.value.availableLocales
                  : Object.keys(_messages.value);
          },
          get modifiers() {
              return (_composer.value ? _composer.value.modifiers : _modifiers);
          },
          get pluralRules() {
              return (_composer.value ? _composer.value.pluralRules : _pluralRules);
          },
          get isGlobal() {
              return _composer.value ? _composer.value.isGlobal : false;
          },
          get missingWarn() {
              return _composer.value ? _composer.value.missingWarn : _missingWarn;
          },
          set missingWarn(val) {
              if (_composer.value) {
                  _composer.value.missingWarn = val;
              }
          },
          get fallbackWarn() {
              return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
          },
          set fallbackWarn(val) {
              if (_composer.value) {
                  _composer.value.missingWarn = val;
              }
          },
          get fallbackRoot() {
              return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
          },
          set fallbackRoot(val) {
              if (_composer.value) {
                  _composer.value.fallbackRoot = val;
              }
          },
          get fallbackFormat() {
              return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
          },
          set fallbackFormat(val) {
              if (_composer.value) {
                  _composer.value.fallbackFormat = val;
              }
          },
          get warnHtmlMessage() {
              return _composer.value
                  ? _composer.value.warnHtmlMessage
                  : _warnHtmlMessage;
          },
          set warnHtmlMessage(val) {
              if (_composer.value) {
                  _composer.value.warnHtmlMessage = val;
              }
          },
          get escapeParameter() {
              return _composer.value
                  ? _composer.value.escapeParameter
                  : _escapeParameter;
          },
          set escapeParameter(val) {
              if (_composer.value) {
                  _composer.value.escapeParameter = val;
              }
          },
          t,
          getPostTranslationHandler,
          setPostTranslationHandler,
          getMissingHandler,
          setMissingHandler,
          rt,
          d,
          n,
          tm,
          te,
          getLocaleMessage,
          setLocaleMessage,
          mergeLocaleMessage,
          getDateTimeFormat,
          setDateTimeFormat,
          mergeDateTimeFormat,
          getNumberFormat,
          setNumberFormat,
          mergeNumberFormat
      };
      function sync(composer) {
          composer.locale.value = _locale.value;
          composer.fallbackLocale.value = _fallbackLocale.value;
          Object.keys(_messages.value).forEach(locale => {
              composer.mergeLocaleMessage(locale, _messages.value[locale]);
          });
          Object.keys(_datetimeFormats.value).forEach(locale => {
              composer.mergeDateTimeFormat(locale, _datetimeFormats.value[locale]);
          });
          Object.keys(_numberFormats.value).forEach(locale => {
              composer.mergeNumberFormat(locale, _numberFormats.value[locale]);
          });
          composer.escapeParameter = _escapeParameter;
          composer.fallbackFormat = _fallbackFormat;
          composer.fallbackRoot = _fallbackRoot;
          composer.fallbackWarn = _fallbackWarn;
          composer.missingWarn = _missingWarn;
          composer.warnHtmlMessage = _warnHtmlMessage;
      }
      vueDemi.onBeforeMount(() => {
          if (instance.proxy == null || instance.proxy.$i18n == null) {
              throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const composer = (_composer.value = instance.proxy.$i18n
              .__composer);
          if (scope === 'global') {
              _locale.value = composer.locale.value;
              _fallbackLocale.value = composer.fallbackLocale.value;
              _messages.value = composer.messages.value;
              _datetimeFormats.value = composer.datetimeFormats.value;
              _numberFormats.value = composer.numberFormats.value;
          }
          else if (isLocalScope) {
              sync(composer);
          }
      });
      return wrapper;
  }
  function injectGlobalFieldsForBridge(Vue, // eslint-disable-line @typescript-eslint/no-explicit-any
  i18n, // eslint-disable-line @typescript-eslint/no-explicit-any
  composer) {
      // The composition mode in vue-i18n-bridge is `$18n` is the VueI18n instance.
      // so we need to tell composer to change the locale.
      // If we don't do, things like `$t` that are injected will not be reacted.
      const watcher = i18n.watchLocale(composer);
      // define fowardcompatible vue-i18n-next inject fields with `globalInjection`
      Vue.prototype.$t = function (...args) {
          return Reflect.apply(composer.t, composer, [...args]);
      };
      Vue.prototype.$d = function (...args) {
          return Reflect.apply(composer.d, composer, [...args]);
      };
      Vue.prototype.$n = function (...args) {
          return Reflect.apply(composer.n, composer, [...args]);
      };
      return watcher;
  }

  // register message resolver at vue-i18n
  registerMessageResolver(resolveValue);
  // register fallback locale at vue-i18n
  registerLocaleFallbacker(fallbackWithLocaleChain);
  // NOTE: experimental !!
  {
      const target = getGlobalThis();
      target.__INTLIFY__ = true;
      setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  {
      initDev();
  }

  exports.DatetimeFormat = DatetimeFormat;
  exports.I18nD = I18nD;
  exports.I18nInjectionKey = I18nInjectionKey;
  exports.I18nN = I18nN;
  exports.I18nT = I18nT;
  exports.NumberFormat = NumberFormat;
  exports.Translation = Translation;
  exports.VERSION = VERSION;
  exports.castToVueI18n = castToVueI18n;
  exports.createI18n = createI18n;
  exports.useI18n = useI18n;

  return exports;

})({}, VueDemi);
